/*
 * A V4L2 driver for samsung s5k4ec cameras.
 *
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/clk.h>
#include <media/v4l2-device.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-mediabus.h>
#include <linux/io.h>


#include "camera.h"


MODULE_AUTHOR("raymonxiu");
MODULE_DESCRIPTION("A low-level driver for samsung s5k4ec mipi sensors");
MODULE_LICENSE("GPL");

#define DEV_DBG_EN      1 
#if(DEV_DBG_EN == 1)    
#define vfe_dev_dbg(x,arg...) printk("[S5K4EC_MIPI]"x,##arg)
#else
#define vfe_dev_dbg(x,arg...) 
#endif
#define vfe_dev_err(x,arg...) printk("[S5K4EC_MIPI]"x,##arg)
#define vfe_dev_print(x,arg...) printk("[S5K4EC_MIPI]"x,##arg)

#define LOG_ERR_RET(x)  { \
                          int ret;  \
                          ret = x; \
                          if(ret < 0) {\
                            vfe_dev_err("error at %s\n",__func__);  \
                            return ret; \
                          } \
                        }

#define MCLK              (24*1000*1000)
#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_HIGH
#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
#define V4L2_IDENT_SENSOR 0x4ec

#define CSI_STBY_ON			0
#define CSI_STBY_OFF 		1
#define CSI_RST_ON			0
#define CSI_RST_OFF			1
#define CSI_PWR_ON			1
#define CSI_PWR_OFF			0
#define CSI_AF_PWR_ON		0
#define CSI_AF_PWR_OFF	1

#define regval_list reg_list_a16_d16

#define REG_TERM 0xfffe
#define VAL_TERM 0xfe
#define REG_DLY  0xffff

#define CONTINUEOUS_AF

#define AF_WIN_NEW_COORD

unsigned int coarse_af_pd=0;

/*
 * Our nominal (default) frame rate.
 */
#define SENSOR_FRAME_RATE 30

/*
 * The s5k4ec sits on i2c with ID 0x5a
 */
#define I2C_ADDR 0x5a
#define SENSOR_NAME "s5k4ec_mipi"
/* Registers */


static int sensor_s_band_filter(struct v4l2_subdev *sd, 
		enum v4l2_power_line_frequency value);

		
/*
 * Information we maintain about a known sensor.
 */
struct sensor_format_struct;  /* coming later */

struct cfg_array { /* coming later */
	struct regval_list * regs;
	int size;
};

static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
{
  return container_of(sd, struct sensor_info, sd);
}


/*
 * The default register settings
 *
 */

static struct regval_list sensor_default_regs[] = {
  

{0xFCFC, 0xD000},
{0x0010, 0x0001},
{0x1030, 0x0000},
{0x0014, 0x0001},





{0x002A,	0x1082},
{0x0F12,	0x0000},
{0x0F12,	0x0000},
{0x002A,	0x1088},
{0x0F12,	0x0000},



{0x0028, 0xD000},
{0x002A, 0x007A},
{0x0f12, 0x0000},	
{0x002A, 0xE406},	
{0x0F12, 0x0092},	
{0x002A, 0xE410},	
{0x0F12, 0x3804},	
{0x002A, 0xE41A},	
{0x0F12, 0x0010},	 	
{0x002A, 0xE420},	
{0x0F12, 0x0003},	
{0x0F12, 0x0060},	
{0x002A, 0xE42E},	
{0x0F12, 0x0004},	
{0x002A, 0xF400},	
{0x0F12, 0x5A3C},	
{0x0F12, 0x0023},	
{0x0F12, 0x8080},	
{0x0F12, 0x03AF},	
{0x0F12, 0x000A},	
{0x0F12, 0xAA54},	
{0x0F12, 0x0040},	
{0x0F12, 0x464E},	
{0x0F12, 0x0240},	
{0x0F12, 0x0240},	
{0x0F12, 0x0040},	
{0x0F12, 0x1000},	
{0x0F12, 0x55cc},	
{0x0F12, 0xD000},	
{0x0F12, 0x0010},	
{0x0F12, 0x0202},	
{0x0F12, 0x0401},	
{0x0F12, 0x0022},	
{0x0F12, 0x0088},	
{0x0F12, 0x009F},	
{0x0F12, 0x0000},	
{0x0F12, 0x1800},	
{0x0F12, 0x0088},	
{0x0F12, 0x0000},	
{0x0F12, 0x2428},	
{0x0F12, 0x0000},	
{0x0F12, 0x03EE},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x002A, 0xF552},	
{0x0F12, 0x0708},	
{0x0F12, 0x080C},	


{0x0028, 0x7000},	
{0x002A, 0x18BC},	
{0x0F12, 0x0004},	
{0x0F12, 0x05B6},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0001},	
{0x0F12, 0x05BA},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0007},	
{0x0F12, 0x05BA},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x01F4},	
{0x0F12, 0x024E},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x01F4},	
{0x0F12, 0x05B6},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x01F4},	
{0x0F12, 0x05BA},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x01F4},	
{0x0F12, 0x024F},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0075},	
{0x0F12, 0x00CF},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0075},	
{0x0F12, 0x00D6},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0004},	
{0x0F12, 0x01F4},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00F0},	
{0x0F12, 0x01F4},	
{0x0F12, 0x029E},	
{0x0F12, 0x05B2},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x01F8},	
{0x0F12, 0x0228},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0208},	
{0x0F12, 0x0238},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0218},	
{0x0F12, 0x0238},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0001},	
{0x0F12, 0x0009},	
{0x0F12, 0x00DE},	
{0x0F12, 0x05C0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00DF},	
{0x0F12, 0x00E4},	
{0x0F12, 0x01F8},	
{0x0F12, 0x01FD},	
{0x0F12, 0x05B6},	
{0x0F12, 0x05BB},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x01F8},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0077},	
{0x0F12, 0x007E},	
{0x0F12, 0x024F},	
{0x0F12, 0x025E},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	


{0x0F12, 0x0004},	
{0x0F12, 0x09D1},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0001},	
{0x0F12, 0x09D5},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0008},	
{0x0F12, 0x09D5},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02AA},	
{0x0F12, 0x0326},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02AA},	
{0x0F12, 0x09D1},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02AA},	
{0x0F12, 0x09D5},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02AA},	
{0x0F12, 0x0327},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0008},	
{0x0F12, 0x0084},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0008},	
{0x0F12, 0x008D},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0008},	
{0x0F12, 0x02AA},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00AA},	
{0x0F12, 0x02AA},	
{0x0F12, 0x03AD},	
{0x0F12, 0x09CD},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02AE},	
{0x0F12, 0x02DE},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02BE},	
{0x0F12, 0x02EE},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02CE},	
{0x0F12, 0x02EE},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0001},	
{0x0F12, 0x0009},	
{0x0F12, 0x0095},	
{0x0F12, 0x09DB},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0096},	
{0x0F12, 0x009B},	
{0x0F12, 0x02AE},	
{0x0F12, 0x02B3},	
{0x0F12, 0x09D1},	
{0x0F12, 0x09D6},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x02AE},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0009},	
{0x0F12, 0x0010},	
{0x0F12, 0x0327},	
{0x0F12, 0x0336},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	     
{0x002A, 0x1AF8},	
{0x0F12, 0x5A3C},   
{0x002A, 0x1896},	
{0x0F12, 0x0002},   
{0x0F12, 0x0000},   
{0x0F12, 0x0003},	
{0x002A, 0x189E},	
{0x0F12, 0x0FB0},	
{0x002A, 0x18AC},	
{0x0F12, 0x0060},	
{0x0F12, 0x0060},	
{0x0F12, 0x05C0},	
{0x0F12, 0x05C0},	
{0x002A, 0x1AEA},	
{0x0F12, 0x8080},	
{0x0F12, 0x0080},	
{0x002A, 0x1AE0},	
{0x0F12, 0x0000},	
{0x002A, 0x1A72},	
{0x0F12, 0x0000},	
{0x002A, 0x18A2},	
{0x0F12, 0x0004},	
{0x002A, 0x1A6A},	
{0x0F12, 0x009A},	
{0x002A, 0x385E},	
{0x0F12, 0x024C},	
{0x002A, 0x0EE6},	
{0x0F12, 0x0000},	
{0x002A, 0x1B2A},	
{0x0F12, 0x0300},	
{0x0F12, 0x00D6},	
{0x0F12, 0x008D},	
{0x0F12, 0x00CF},	
{0x0F12, 0x0084},	

	

{0x0028, 0x7000},
{0x002A, 0x3AF8},
{0x0F12, 0xB570},	
{0x0F12, 0x4B39},	
{0x0F12, 0x4939},	
{0x0F12, 0x483A},	
{0x0F12, 0x2200},	
{0x0F12, 0xC008},	
{0x0F12, 0x6001},	
{0x0F12, 0x4939},	
{0x0F12, 0x4839},	
{0x0F12, 0x2401},	
{0x0F12, 0xF000},	
{0x0F12, 0xFBEC},	
{0x0F12, 0x4938},	
{0x0F12, 0x4839},	
{0x0F12, 0x2502},	
{0x0F12, 0x0022},	
{0x0F12, 0xF000},	
{0x0F12, 0xFBE6},	
{0x0F12, 0x4837},	
{0x0F12, 0x0261},	
{0x0F12, 0x8001},	
{0x0F12, 0x2100},	
{0x0F12, 0x8041},	
{0x0F12, 0x4936},	
{0x0F12, 0x4836},	
{0x0F12, 0x6041},	
{0x0F12, 0x4936},	
{0x0F12, 0x4837},	
{0x0F12, 0x2403},	
{0x0F12, 0x002A},	
{0x0F12, 0xF000},	
{0x0F12, 0xFBD8},	
{0x0F12, 0x4832},	
{0x0F12, 0x4935},	
{0x0F12, 0x30C0},	
{0x0F12, 0x63C1},	
{0x0F12, 0x4930},	
{0x0F12, 0x4834},	
{0x0F12, 0x3980},	
{0x0F12, 0x6408},	
{0x0F12, 0x4833},	
{0x0F12, 0x4934},	
{0x0F12, 0x6388},	
{0x0F12, 0x4934},	
{0x0F12, 0x4834},	
{0x0F12, 0x0022},	
{0x0F12, 0x2504},	
{0x0F12, 0xF000},	
{0x0F12, 0xFBC7},	
{0x0F12, 0x4933},	
{0x0F12, 0x4833},	
{0x0F12, 0x2405},	
{0x0F12, 0x002A},	
{0x0F12, 0xF000},	
{0x0F12, 0xF881},	
{0x0F12, 0x491F},	
{0x0F12, 0x4830},	
{0x0F12, 0x0022},	
{0x0F12, 0x2506},	
{0x0F12, 0x39B6},	
{0x0F12, 0x1D80},	
{0x0F12, 0xF000},	
{0x0F12, 0xF879},	
{0x0F12, 0x482D},	
{0x0F12, 0x492D},	
{0x0F12, 0x2407},	
{0x0F12, 0x002A},	
{0x0F12, 0x300C},	
{0x0F12, 0xF000},	
{0x0F12, 0xF872},	
{0x0F12, 0x4829},	
{0x0F12, 0x492B},	
{0x0F12, 0x0022},	
{0x0F12, 0x2508},	
{0x0F12, 0x3010},	
{0x0F12, 0xF000},	
{0x0F12, 0xF86B},	
{0x0F12, 0x4929},	
{0x0F12, 0x4829},	
{0x0F12, 0x2409},	
{0x0F12, 0x002A},	
{0x0F12, 0xF000},	
{0x0F12, 0xFBA5},	
{0x0F12, 0x4928},	
{0x0F12, 0x4828},	
{0x0F12, 0x0022},	
{0x0F12, 0x250A},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB9F},	
{0x0F12, 0x4927},	
{0x0F12, 0x4827},	
{0x0F12, 0x240B},	
{0x0F12, 0x002A},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB99},	
{0x0F12, 0x4926},	
{0x0F12, 0x4826},	
{0x0F12, 0x0022},	
{0x0F12, 0x250C},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB93},	
{0x0F12, 0x4925},	
{0x0F12, 0x4825},	
{0x0F12, 0x240D},	
{0x0F12, 0x002A},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB8D},	
{0x0F12, 0x4924},	
{0x0F12, 0x4824},	
{0x0F12, 0x0022},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB88},	
{0x0F12, 0xBC70},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0x0000},	
{0x0F12, 0x017B},	
{0x0F12, 0x4EC2},	
{0x0F12, 0x037F},	
{0x0F12, 0x0000},	
{0x0F12, 0x1F90},	
{0x0F12, 0x7000},	
{0x0F12, 0x3C81},	
{0x0F12, 0x7000},	
{0x0F12, 0xE38B},	
{0x0F12, 0x0000},	
{0x0F12, 0x3CB9},	
{0x0F12, 0x7000},	
{0x0F12, 0xC3B1},	
{0x0F12, 0x0000},	
{0x0F12, 0x4780},	
{0x0F12, 0x7000},	
{0x0F12, 0x3D17},	
{0x0F12, 0x7000},	
{0x0F12, 0x0080},	
{0x0F12, 0x7000},	
{0x0F12, 0x3D53},	
{0x0F12, 0x7000},	
{0x0F12, 0xB49D},	
{0x0F12, 0x0000},	
{0x0F12, 0x3DFF},	
{0x0F12, 0x7000},	
{0x0F12, 0x3DB3},	
{0x0F12, 0x7000},	
{0x0F12, 0xFFFF},	
{0x0F12, 0x00FF},	
{0x0F12, 0x17E0},	
{0x0F12, 0x7000},	
{0x0F12, 0x3F7B},	
{0x0F12, 0x7000},	
{0x0F12, 0x053D},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0A89},	
{0x0F12, 0x6CD2},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0A9A},	
{0x0F12, 0x0000},	
{0x0F12, 0x02D2},	
{0x0F12, 0x3FC9},	
{0x0F12, 0x7000},	
{0x0F12, 0x9E65},	
{0x0F12, 0x0000},	
{0x0F12, 0x403D},	
{0x0F12, 0x7000},	
{0x0F12, 0x7C49},	
{0x0F12, 0x0000},	
{0x0F12, 0x40B1},	
{0x0F12, 0x7000},	
{0x0F12, 0x7C63},	
{0x0F12, 0x0000},	
{0x0F12, 0x40CD},	
{0x0F12, 0x7000},	
{0x0F12, 0x8F01},	
{0x0F12, 0x0000},	
{0x0F12, 0x416F},	
{0x0F12, 0x7000},	
{0x0F12, 0x7F3F},	
{0x0F12, 0x0000},	
{0x0F12, 0x41FD},	
{0x0F12, 0x7000},	
{0x0F12, 0x98C5},	
{0x0F12, 0x0000},	
{0x0F12, 0xB570},	
{0x0F12, 0x000C},	
{0x0F12, 0x0015},	
{0x0F12, 0x0029},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB42},	
{0x0F12, 0x49F8},	
{0x0F12, 0x00A8},	
{0x0F12, 0x500C},	
{0x0F12, 0xBC70},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0x6808},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x6849},	
{0x0F12, 0x0409},	
{0x0F12, 0x0C09},	
{0x0F12, 0x4AF3},	
{0x0F12, 0x8992},	
{0x0F12, 0x2A00},	
{0x0F12, 0xD00D},	
{0x0F12, 0x2300},	
{0x0F12, 0x1A89},	
{0x0F12, 0xD400},	
{0x0F12, 0x000B},	
{0x0F12, 0x0419},	
{0x0F12, 0x0C09},	
{0x0F12, 0x23FF},	
{0x0F12, 0x33C1},	
{0x0F12, 0x1810},	
{0x0F12, 0x4298},	
{0x0F12, 0xD800},	
{0x0F12, 0x0003},	
{0x0F12, 0x0418},	
{0x0F12, 0x0C00},	
{0x0F12, 0x4AEB},	
{0x0F12, 0x8150},	
{0x0F12, 0x8191},	
{0x0F12, 0x4770},	
{0x0F12, 0xB5F3},	
{0x0F12, 0x0004},	
{0x0F12, 0xB081},	
{0x0F12, 0x9802},	
{0x0F12, 0x6800},	
{0x0F12, 0x0600},	
{0x0F12, 0x0E00},	
{0x0F12, 0x2201},	
{0x0F12, 0x0015},	
{0x0F12, 0x0021},	
{0x0F12, 0x3910},	
{0x0F12, 0x408A},	
{0x0F12, 0x40A5},	
{0x0F12, 0x4FE4},	
{0x0F12, 0x0016},	
{0x0F12, 0x2C10},	
{0x0F12, 0xDA03},	
{0x0F12, 0x8839},	
{0x0F12, 0x43A9},	
{0x0F12, 0x8039},	
{0x0F12, 0xE002},	
{0x0F12, 0x8879},	
{0x0F12, 0x43B1},	
{0x0F12, 0x8079},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB0E},	
{0x0F12, 0x2C10},	
{0x0F12, 0xDA03},	
{0x0F12, 0x8839},	
{0x0F12, 0x4329},	
{0x0F12, 0x8039},	
{0x0F12, 0xE002},	
{0x0F12, 0x8879},	
{0x0F12, 0x4331},	
{0x0F12, 0x8079},	
{0x0F12, 0x49DA},	
{0x0F12, 0x8809},	
{0x0F12, 0x2900},	
{0x0F12, 0xD102},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB07},	
{0x0F12, 0x2000},	
{0x0F12, 0x9902},	
{0x0F12, 0x6008},	
{0x0F12, 0xBCFE},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0xB538},	
{0x0F12, 0x9C04},	
{0x0F12, 0x0015},	
{0x0F12, 0x002A},	
{0x0F12, 0x9400},	
{0x0F12, 0xF000},	
{0x0F12, 0xFB02},	
{0x0F12, 0x4AD1},	
{0x0F12, 0x8811},	
{0x0F12, 0x2900},	
{0x0F12, 0xD00F},	
{0x0F12, 0x8820},	
{0x0F12, 0x4281},	
{0x0F12, 0xD20C},	
{0x0F12, 0x8861},	
{0x0F12, 0x8853},	
{0x0F12, 0x4299},	
{0x0F12, 0xD200},	
{0x0F12, 0x1E40},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x8020},	
{0x0F12, 0x8851},	
{0x0F12, 0x8061},	
{0x0F12, 0x4368},	
{0x0F12, 0x1840},	
{0x0F12, 0x6060},	
{0x0F12, 0xBC38},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0xB5F8},	
{0x0F12, 0x0004},	
{0x0F12, 0x6808},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x2201},	
{0x0F12, 0x0015},	
{0x0F12, 0x0021},	
{0x0F12, 0x3910},	
{0x0F12, 0x408A},	
{0x0F12, 0x40A5},	
{0x0F12, 0x4FBE},	
{0x0F12, 0x0016},	
{0x0F12, 0x2C10},	
{0x0F12, 0xDA03},	
{0x0F12, 0x8839},	
{0x0F12, 0x43A9},	
{0x0F12, 0x8039},	
{0x0F12, 0xE002},	
{0x0F12, 0x8879},	
{0x0F12, 0x43B1},	
{0x0F12, 0x8079},	
{0x0F12, 0xF000},	
{0x0F12, 0xFADB},	
{0x0F12, 0x2C10},	
{0x0F12, 0xDA03},	
{0x0F12, 0x8838},	
{0x0F12, 0x4328},	
{0x0F12, 0x8038},	
{0x0F12, 0xE002},	
{0x0F12, 0x8878},	
{0x0F12, 0x4330},	
{0x0F12, 0x8078},	
{0x0F12, 0x48B6},	
{0x0F12, 0x8800},	
{0x0F12, 0x0400},	
{0x0F12, 0xD507},	
{0x0F12, 0x4BB5},	
{0x0F12, 0x7819},	
{0x0F12, 0x4AB5},	
{0x0F12, 0x7810},	
{0x0F12, 0x7018},	
{0x0F12, 0x7011},	
{0x0F12, 0x49B4},	
{0x0F12, 0x8188},	
{0x0F12, 0xBCF8},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0xB538},	
{0x0F12, 0x48B2},	
{0x0F12, 0x4669},	
{0x0F12, 0xF000},	
{0x0F12, 0xFAC6},	
{0x0F12, 0x48B1},	
{0x0F12, 0x49B0},	
{0x0F12, 0x69C2},	
{0x0F12, 0x2400},	
{0x0F12, 0x31A8},	
{0x0F12, 0x2A00},	
{0x0F12, 0xD008},	
{0x0F12, 0x61C4},	
{0x0F12, 0x684A},	
{0x0F12, 0x6242},	
{0x0F12, 0x6282},	
{0x0F12, 0x466B},	
{0x0F12, 0x881A},	
{0x0F12, 0x6302},	
{0x0F12, 0x885A},	
{0x0F12, 0x6342},	
{0x0F12, 0x6A02},	
{0x0F12, 0x2A00},	
{0x0F12, 0xD00A},	
{0x0F12, 0x6204},	
{0x0F12, 0x6849},	
{0x0F12, 0x6281},	
{0x0F12, 0x466B},	
{0x0F12, 0x8819},	
{0x0F12, 0x6301},	
{0x0F12, 0x8859},	
{0x0F12, 0x6341},	
{0x0F12, 0x49A5},	
{0x0F12, 0x88C9},	
{0x0F12, 0x63C1},	
{0x0F12, 0xF000},	
{0x0F12, 0xFAAE},	
{0x0F12, 0xE7A6},	
{0x0F12, 0xB5F0},	
{0x0F12, 0xB08B},	
{0x0F12, 0x20FF},	
{0x0F12, 0x1C40},	
{0x0F12, 0x49A1},	
{0x0F12, 0x89CC},	
{0x0F12, 0x4E9E},	
{0x0F12, 0x6AB1},	
{0x0F12, 0x4284},	
{0x0F12, 0xD101},	
{0x0F12, 0x489F},	
{0x0F12, 0x6081},	
{0x0F12, 0x6A70},	
{0x0F12, 0x0200},	
{0x0F12, 0xF000},	
{0x0F12, 0xFAA5},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x4A96},	
{0x0F12, 0x8A11},	
{0x0F12, 0x9109},	
{0x0F12, 0x2101},	
{0x0F12, 0x0349},	
{0x0F12, 0x4288},	
{0x0F12, 0xD200},	
{0x0F12, 0x0001},	
{0x0F12, 0x4A92},	
{0x0F12, 0x8211},	
{0x0F12, 0x4D97},	
{0x0F12, 0x8829},	
{0x0F12, 0x9108},	
{0x0F12, 0x4A8B},	
{0x0F12, 0x2303},	
{0x0F12, 0x3222},	
{0x0F12, 0x1F91},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA96},	
{0x0F12, 0x8028},	
{0x0F12, 0x488E},	
{0x0F12, 0x4987},	
{0x0F12, 0x6BC2},	
{0x0F12, 0x6AC0},	
{0x0F12, 0x4282},	
{0x0F12, 0xD201},	
{0x0F12, 0x8CC8},	
{0x0F12, 0x8028},	
{0x0F12, 0x88E8},	
{0x0F12, 0x9007},	
{0x0F12, 0x2240},	
{0x0F12, 0x4310},	
{0x0F12, 0x80E8},	
{0x0F12, 0x2000},	
{0x0F12, 0x0041},	
{0x0F12, 0x194B},	
{0x0F12, 0x001E},	
{0x0F12, 0x3680},	
{0x0F12, 0x8BB2},	
{0x0F12, 0xAF04},	
{0x0F12, 0x527A},	
{0x0F12, 0x4A7D},	
{0x0F12, 0x188A},	
{0x0F12, 0x8897},	
{0x0F12, 0x83B7},	
{0x0F12, 0x33A0},	
{0x0F12, 0x891F},	
{0x0F12, 0xAE01},	
{0x0F12, 0x5277},	
{0x0F12, 0x8A11},	
{0x0F12, 0x8119},	
{0x0F12, 0x1C40},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x2806},	
{0x0F12, 0xD3E9},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA77},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA7D},	
{0x0F12, 0x4F79},	
{0x0F12, 0x37A8},	
{0x0F12, 0x2800},	
{0x0F12, 0xD10A},	
{0x0F12, 0x1FE0},	
{0x0F12, 0x38FD},	
{0x0F12, 0xD001},	
{0x0F12, 0x1CC0},	
{0x0F12, 0xD105},	
{0x0F12, 0x4874},	
{0x0F12, 0x8829},	
{0x0F12, 0x3818},	
{0x0F12, 0x6840},	
{0x0F12, 0x4348},	
{0x0F12, 0x6078},	
{0x0F12, 0x4972},	
{0x0F12, 0x6878},	
{0x0F12, 0x6B89},	
{0x0F12, 0x4288},	
{0x0F12, 0xD300},	
{0x0F12, 0x0008},	
{0x0F12, 0x6078},	
{0x0F12, 0x2000},	
{0x0F12, 0x0041},	
{0x0F12, 0xAA04},	
{0x0F12, 0x5A53},	
{0x0F12, 0x194A},	
{0x0F12, 0x269C},	
{0x0F12, 0x52B3},	
{0x0F12, 0xAB01},	
{0x0F12, 0x5A59},	
{0x0F12, 0x32A0},	
{0x0F12, 0x8111},	
{0x0F12, 0x1C40},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x2806},	
{0x0F12, 0xD3F0},	
{0x0F12, 0x4965},	
{0x0F12, 0x9809},	
{0x0F12, 0x8208},	
{0x0F12, 0x9808},	
{0x0F12, 0x8028},	
{0x0F12, 0x9807},	
{0x0F12, 0x80E8},	
{0x0F12, 0x1FE0},	
{0x0F12, 0x38FD},	
{0x0F12, 0xD13B},	
{0x0F12, 0x4D64},	
{0x0F12, 0x89E8},	
{0x0F12, 0x1FC1},	
{0x0F12, 0x39FF},	
{0x0F12, 0xD136},	
{0x0F12, 0x4C5F},	
{0x0F12, 0x8AE0},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA4C},	
{0x0F12, 0x0006},	
{0x0F12, 0x8B20},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA50},	
{0x0F12, 0x9000},	
{0x0F12, 0x6AA1},	
{0x0F12, 0x6878},	
{0x0F12, 0x1809},	
{0x0F12, 0x0200},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA23},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x0022},	
{0x0F12, 0x3246},	
{0x0F12, 0x0011},	
{0x0F12, 0x310A},	
{0x0F12, 0x2305},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA20},	
{0x0F12, 0x66E8},	
{0x0F12, 0x6B23},	
{0x0F12, 0x0002},	
{0x0F12, 0x0031},	
{0x0F12, 0x0018},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA41},	
{0x0F12, 0x466B},	
{0x0F12, 0x8518},	
{0x0F12, 0x6EEA},	
{0x0F12, 0x6B60},	
{0x0F12, 0x9900},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA3A},	
{0x0F12, 0x466B},	
{0x0F12, 0x8558},	
{0x0F12, 0x0029},	
{0x0F12, 0x980A},	
{0x0F12, 0x3170},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA3B},	
{0x0F12, 0x0028},	
{0x0F12, 0x3060},	
{0x0F12, 0x8A02},	
{0x0F12, 0x4946},	
{0x0F12, 0x3128},	
{0x0F12, 0x808A},	
{0x0F12, 0x8A42},	
{0x0F12, 0x80CA},	
{0x0F12, 0x8A80},	
{0x0F12, 0x8108},	
{0x0F12, 0xB00B},	
{0x0F12, 0xBCF0},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0xB570},	
{0x0F12, 0x2400},	
{0x0F12, 0x4D46},	
{0x0F12, 0x4846},	
{0x0F12, 0x8881},	
{0x0F12, 0x4846},	
{0x0F12, 0x8041},	
{0x0F12, 0x2101},	
{0x0F12, 0x8001},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA2A},	
{0x0F12, 0x4842},	
{0x0F12, 0x3820},	
{0x0F12, 0x8BC0},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA2D},	
{0x0F12, 0x4B42},	
{0x0F12, 0x220D},	
{0x0F12, 0x0712},	
{0x0F12, 0x18A8},	
{0x0F12, 0x8806},	
{0x0F12, 0x00E1},	
{0x0F12, 0x18C9},	
{0x0F12, 0x81CE},	
{0x0F12, 0x8846},	
{0x0F12, 0x818E},	
{0x0F12, 0x8886},	
{0x0F12, 0x824E},	
{0x0F12, 0x88C0},	
{0x0F12, 0x8208},	
{0x0F12, 0x3508},	
{0x0F12, 0x042D},	
{0x0F12, 0x0C2D},	
{0x0F12, 0x1C64},	
{0x0F12, 0x0424},	
{0x0F12, 0x0C24},	
{0x0F12, 0x2C07},	
{0x0F12, 0xD3EC},	
{0x0F12, 0xE658},	
{0x0F12, 0xB510},	
{0x0F12, 0x4834},	
{0x0F12, 0x4C34},	
{0x0F12, 0x88C0},	
{0x0F12, 0x8060},	
{0x0F12, 0x2001},	
{0x0F12, 0x8020},	
{0x0F12, 0x4831},	
{0x0F12, 0x3820},	
{0x0F12, 0x8BC0},	
{0x0F12, 0xF000},	
{0x0F12, 0xFA0A},	
{0x0F12, 0x88E0},	
{0x0F12, 0x4A31},	
{0x0F12, 0x2800},	
{0x0F12, 0xD003},	
{0x0F12, 0x4930},	
{0x0F12, 0x8849},	
{0x0F12, 0x2900},	
{0x0F12, 0xD009},	
{0x0F12, 0x2001},	
{0x0F12, 0x03C0},	
{0x0F12, 0x8050},	
{0x0F12, 0x80D0},	
{0x0F12, 0x2000},	
{0x0F12, 0x8090},	
{0x0F12, 0x8110},	
{0x0F12, 0xBC10},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0x8050},	
{0x0F12, 0x8920},	
{0x0F12, 0x80D0},	
{0x0F12, 0x8960},	
{0x0F12, 0x0400},	
{0x0F12, 0x1400},	
{0x0F12, 0x8090},	
{0x0F12, 0x89A1},	
{0x0F12, 0x0409},	
{0x0F12, 0x1409},	
{0x0F12, 0x8111},	
{0x0F12, 0x89E3},	
{0x0F12, 0x8A24},	
{0x0F12, 0x2B00},	
{0x0F12, 0xD104},	
{0x0F12, 0x17C3},	
{0x0F12, 0x0F5B},	
{0x0F12, 0x1818},	
{0x0F12, 0x10C0},	
{0x0F12, 0x8090},	
{0x0F12, 0x2C00},	
{0x0F12, 0xD1E6},	
{0x0F12, 0x17C8},	
{0x0F12, 0x0F40},	
{0x0F12, 0x1840},	
{0x0F12, 0x10C0},	
{0x0F12, 0x8110},	
{0x0F12, 0xE7E0},	
{0x0F12, 0xB510},	
{0x0F12, 0x000C},	
{0x0F12, 0x4919},	
{0x0F12, 0x2204},	
{0x0F12, 0x6820},	
{0x0F12, 0x5E8A},	
{0x0F12, 0x0140},	
{0x0F12, 0x1A80},	
{0x0F12, 0x0280},	
{0x0F12, 0x8849},	
{0x0F12, 0xF000},	
{0x0F12, 0xF9D8},	
{0x0F12, 0x6020},	
{0x0F12, 0xE7D2},	
{0x0F12, 0x38D4},	
{0x0F12, 0x7000},	
{0x0F12, 0x17D0},	
{0x0F12, 0x7000},	
{0x0F12, 0x5000},	
{0x0F12, 0xD000},	
{0x0F12, 0x1100},	
{0x0F12, 0xD000},	
{0x0F12, 0x171A},	
{0x0F12, 0x7000},	
{0x0F12, 0x4780},	
{0x0F12, 0x7000},	
{0x0F12, 0x2FCA},	
{0x0F12, 0x7000},	
{0x0F12, 0x2FC5},	
{0x0F12, 0x7000},	
{0x0F12, 0x2FC6},	
{0x0F12, 0x7000},	
{0x0F12, 0x2ED8},	
{0x0F12, 0x7000},	
{0x0F12, 0x2BD0},	
{0x0F12, 0x7000},	
{0x0F12, 0x17E0},	
{0x0F12, 0x7000},	
{0x0F12, 0x2DE8},	
{0x0F12, 0x7000},	
{0x0F12, 0x37E0},	
{0x0F12, 0x7000},	
{0x0F12, 0x210C},	
{0x0F12, 0x7000},	
{0x0F12, 0x1484},	
{0x0F12, 0x7000},	
{0x0F12, 0xA006},	
{0x0F12, 0x0000},	
{0x0F12, 0x0724},	
{0x0F12, 0x7000},	
{0x0F12, 0xA000},	
{0x0F12, 0xD000},	
{0x0F12, 0x2270},	
{0x0F12, 0x7000},	
{0x0F12, 0x2558},	
{0x0F12, 0x7000},	
{0x0F12, 0x146C},	
{0x0F12, 0x7000},	
{0x0F12, 0xB510},	
{0x0F12, 0x000C},	
{0x0F12, 0x4983},	
{0x0F12, 0x2208},	
{0x0F12, 0x6820},	
{0x0F12, 0x5E8A},	
{0x0F12, 0x0140},	
{0x0F12, 0x1A80},	
{0x0F12, 0x0280},	
{0x0F12, 0x88C9},	
{0x0F12, 0xF000},	
{0x0F12, 0xF99E},	
{0x0F12, 0x6020},	
{0x0F12, 0xE798},	
{0x0F12, 0xB5FE},	
{0x0F12, 0x000C},	
{0x0F12, 0x6825},	
{0x0F12, 0x6866},	
{0x0F12, 0x68A0},	
{0x0F12, 0x9001},	
{0x0F12, 0x68E7},	
{0x0F12, 0x1BA8},	
{0x0F12, 0x42B5},	
{0x0F12, 0xDA00},	
{0x0F12, 0x1B70},	
{0x0F12, 0x9000},	
{0x0F12, 0x4977},	
{0x0F12, 0x4878},	
{0x0F12, 0x884A},	
{0x0F12, 0x8843},	
{0x0F12, 0x435A},	
{0x0F12, 0x2304},	
{0x0F12, 0x5ECB},	
{0x0F12, 0x0A92},	
{0x0F12, 0x18D2},	
{0x0F12, 0x02D2},	
{0x0F12, 0x0C12},	
{0x0F12, 0x88CB},	
{0x0F12, 0x8880},	
{0x0F12, 0x4343},	
{0x0F12, 0x0A98},	
{0x0F12, 0x2308},	
{0x0F12, 0x5ECB},	
{0x0F12, 0x18C0},	
{0x0F12, 0x02C0},	
{0x0F12, 0x0C00},	
{0x0F12, 0x0411},	
{0x0F12, 0x0400},	
{0x0F12, 0x1409},	
{0x0F12, 0x1400},	
{0x0F12, 0x1A08},	
{0x0F12, 0x496C},	
{0x0F12, 0x39E0},	
{0x0F12, 0x6148},	
{0x0F12, 0x9801},	
{0x0F12, 0x3040},	
{0x0F12, 0x7880},	
{0x0F12, 0x2800},	
{0x0F12, 0xD103},	
{0x0F12, 0x9801},	
{0x0F12, 0x0029},	
{0x0F12, 0xF000},	
{0x0F12, 0xF971},	
{0x0F12, 0x8839},	
{0x0F12, 0x9800},	
{0x0F12, 0x4281},	
{0x0F12, 0xD814},	
{0x0F12, 0x8879},	
{0x0F12, 0x9800},	
{0x0F12, 0x4281},	
{0x0F12, 0xD20C},	
{0x0F12, 0x9801},	
{0x0F12, 0x0029},	
{0x0F12, 0xF000},	
{0x0F12, 0xF96D},	
{0x0F12, 0x9801},	
{0x0F12, 0x0029},	
{0x0F12, 0xF000},	
{0x0F12, 0xF969},	
{0x0F12, 0x9801},	
{0x0F12, 0x0029},	
{0x0F12, 0xF000},	
{0x0F12, 0xF965},	
{0x0F12, 0xE003},	
{0x0F12, 0x9801},	
{0x0F12, 0x0029},	
{0x0F12, 0xF000},	
{0x0F12, 0xF960},	
{0x0F12, 0x9801},	
{0x0F12, 0x0032},	
{0x0F12, 0x0039},	
{0x0F12, 0xF000},	
{0x0F12, 0xF963},	
{0x0F12, 0x6020},	
{0x0F12, 0xE5D0},	
{0x0F12, 0xB57C},	
{0x0F12, 0x4856},	
{0x0F12, 0xA901},	
{0x0F12, 0x0004},	
{0x0F12, 0xF000},	
{0x0F12, 0xF8E7},	
{0x0F12, 0x466B},	
{0x0F12, 0x88D9},	
{0x0F12, 0x8898},	
{0x0F12, 0x4B51},	
{0x0F12, 0x3346},	
{0x0F12, 0x1E9A},	
{0x0F12, 0xF000},	
{0x0F12, 0xF95B},	
{0x0F12, 0x4850},	
{0x0F12, 0x494E},	
{0x0F12, 0x3812},	
{0x0F12, 0x3140},	
{0x0F12, 0x8A42},	
{0x0F12, 0x888B},	
{0x0F12, 0x18D2},	
{0x0F12, 0x8242},	
{0x0F12, 0x8AC2},	
{0x0F12, 0x88C9},	
{0x0F12, 0x1851},	
{0x0F12, 0x82C1},	
{0x0F12, 0x0020},	
{0x0F12, 0x4669},	
{0x0F12, 0xF000},	
{0x0F12, 0xF8CF},	
{0x0F12, 0x4849},	
{0x0F12, 0x214D},	
{0x0F12, 0x8301},	
{0x0F12, 0x2196},	
{0x0F12, 0x8381},	
{0x0F12, 0x211D},	
{0x0F12, 0x3020},	
{0x0F12, 0x8001},	
{0x0F12, 0xF000},	
{0x0F12, 0xF949},	
{0x0F12, 0xF000},	
{0x0F12, 0xF94F},	
{0x0F12, 0x4844},	
{0x0F12, 0x4C44},	
{0x0F12, 0x6E00},	
{0x0F12, 0x60E0},	
{0x0F12, 0x466B},	
{0x0F12, 0x8818},	
{0x0F12, 0x8859},	
{0x0F12, 0x0025},	
{0x0F12, 0x1A40},	
{0x0F12, 0x3540},	
{0x0F12, 0x61A8},	
{0x0F12, 0x483B},	
{0x0F12, 0x9900},	
{0x0F12, 0x3060},	
{0x0F12, 0xF000},	
{0x0F12, 0xF947},	
{0x0F12, 0x466B},	
{0x0F12, 0x8819},	
{0x0F12, 0x1DE0},	
{0x0F12, 0x30F9},	
{0x0F12, 0x8741},	
{0x0F12, 0x8859},	
{0x0F12, 0x8781},	
{0x0F12, 0x2000},	
{0x0F12, 0x71A0},	
{0x0F12, 0x74A8},	
{0x0F12, 0xBC7C},	
{0x0F12, 0xBC08},	
{0x0F12, 0x4718},	
{0x0F12, 0xB5F8},	
{0x0F12, 0x0005},	
{0x0F12, 0x6808},	
{0x0F12, 0x0400},	
{0x0F12, 0x0C00},	
{0x0F12, 0x684A},	
{0x0F12, 0x0412},	
{0x0F12, 0x0C12},	
{0x0F12, 0x688E},	
{0x0F12, 0x68CC},	
{0x0F12, 0x492C},	
{0x0F12, 0x884B},	
{0x0F12, 0x4343},	
{0x0F12, 0x0A98},	
{0x0F12, 0x2304},	
{0x0F12, 0x5ECB},	
{0x0F12, 0x18C0},	
{0x0F12, 0x02C0},	
{0x0F12, 0x0C00},	
{0x0F12, 0x88CB},	
{0x0F12, 0x4353},	
{0x0F12, 0x0A9A},	
{0x0F12, 0x2308},	
{0x0F12, 0x5ECB},	
{0x0F12, 0x18D1},	
{0x0F12, 0x02C9},	
{0x0F12, 0x0C09},	
{0x0F12, 0x2701},	
{0x0F12, 0x003A},	
{0x0F12, 0x40AA},	
{0x0F12, 0x9200},	
{0x0F12, 0x002A},	
{0x0F12, 0x3A10},	
{0x0F12, 0x4097},	
{0x0F12, 0x2D10},	
{0x0F12, 0xDA06},	
{0x0F12, 0x4A25},	
{0x0F12, 0x9B00},	
{0x0F12, 0x8812},	
{0x0F12, 0x439A},	
{0x0F12, 0x4B23},	
{0x0F12, 0x801A},	
{0x0F12, 0xE003},	
{0x0F12, 0x4B22},	
{0x0F12, 0x885A},	
{0x0F12, 0x43BA},	
{0x0F12, 0x805A},	
{0x0F12, 0x0023},	
{0x0F12, 0x0032},	
{0x0F12, 0xF000},	
{0x0F12, 0xF8EF},	
{0x0F12, 0x2D10},	
{0x0F12, 0xDA05},	
{0x0F12, 0x491D},	
{0x0F12, 0x9A00},	
{0x0F12, 0x8808},	
{0x0F12, 0x4310},	
{0x0F12, 0x8008},	
{0x0F12, 0xE003},	
{0x0F12, 0x481A},	
{0x0F12, 0x8841},	
{0x0F12, 0x4339},	
{0x0F12, 0x8041},	
{0x0F12, 0x4D17},	
{0x0F12, 0x2000},	
{0x0F12, 0x3580},	
{0x0F12, 0x88AA},	
{0x0F12, 0x5E30},	
{0x0F12, 0x2100},	
{0x0F12, 0xF000},	
{0x0F12, 0xF8FB},	
{0x0F12, 0x8030},	
{0x0F12, 0x2000},	
{0x0F12, 0x88AA},	
{0x0F12, 0x5E20},	
{0x0F12, 0x2100},	
{0x0F12, 0xF000},	
{0x0F12, 0xF8F4},	
{0x0F12, 0x8020},	
{0x0F12, 0xE587},	
{0x0F12, 0xB510},	
{0x0F12, 0xF000},	
{0x0F12, 0xF8F7},	
{0x0F12, 0x4A0F},	
{0x0F12, 0x8D50},	
{0x0F12, 0x2800},	
{0x0F12, 0xD007},	
{0x0F12, 0x490A},	
{0x0F12, 0x31C0},	
{0x0F12, 0x684B},	
{0x0F12, 0x490C},	
{0x0F12, 0x4283},	
{0x0F12, 0xD202},	
{0x0F12, 0x8D90},	
{0x0F12, 0x81C8},	
{0x0F12, 0xE6A0},	
{0x0F12, 0x8DD0},	
{0x0F12, 0x81C8},	
{0x0F12, 0xE69D},	
{0x0F12, 0x0000},	
{0x0F12, 0x2558},	
{0x0F12, 0x7000},	
{0x0F12, 0x2AB8},	
{0x0F12, 0x7000},	
{0x0F12, 0x145E},	
{0x0F12, 0x7000},	
{0x0F12, 0x2698},	
{0x0F12, 0x7000},	
{0x0F12, 0x2BB8},	
{0x0F12, 0x7000},	
{0x0F12, 0x2998},	
{0x0F12, 0x7000},	
{0x0F12, 0x1100},	
{0x0F12, 0xD000},	
{0x0F12, 0x4780},	
{0x0F12, 0x7000},	
{0x0F12, 0xE200},	
{0x0F12, 0xD000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x1789},	
{0x0F12, 0x0001},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x16F1},	
{0x0F12, 0x0001},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xC3B1},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xC36D},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xF6D7},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xB49D},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x7EDF},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x448D},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xF004},	
{0x0F12, 0xE51F},	
{0x0F12, 0x29EC},	
{0x0F12, 0x0001},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x2EF1},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xEE03},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xA58B},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x7C49},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x7C63},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x2DB7},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xEB3D},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xF061},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xF0EF},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xF004},	
{0x0F12, 0xE51F},	
{0x0F12, 0x2824},	
{0x0F12, 0x0001},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x8EDD},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x8DCB},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x8E17},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x98C5},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x7C7D},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x7E31},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x7EAB},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0x7501},	
{0x0F12, 0x0000},	
{0x0F12, 0x4778},	
{0x0F12, 0x46C0},	
{0x0F12, 0xC000},	
{0x0F12, 0xE59F},	
{0x0F12, 0xFF1C},	
{0x0F12, 0xE12F},	
{0x0F12, 0xF63F},	
{0x0F12, 0x0000},	



{0x0028, 0xD000}, 
{0x002A, 0x1000}, 
{0x0F12, 0x0001},




{0x0028, 0x7000},
{0x002A, 0x01FC},
{0x0F12, 0x0001},	
{0x002A, 0x01FE},
{0x0F12, 0x0003},	
{0x0F12, 0x0000},	
{0x002A, 0x0204},
{0x0F12, 0x0061},	
{0x002A, 0x020C},
{0x0F12, 0x2F0C},	
{0x0F12, 0x0190},	
{0x002A, 0x0294},
{0x0F12, 0x01C7},	
{0x0F12, 0x01C7},	
{0x0F12, 0x0072},	
{0x0F12, 0x0072},	
{0x0F12, 0x01D5},	
{0x0F12, 0x01D5},	
{0x0F12, 0x0055},	
{0x0F12, 0x0055},	
{0x0F12, 0x0001},	
     
{0x002A, 0x070E},
{0x0F12, 0x00FF},	
{0x002A, 0x071E},
{0x0F12, 0x0000},	
{0x002A, 0x163C},
{0x0F12, 0x0000},	
{0x002A, 0x1648},
{0x0F12, 0x9000},	
{0x002A, 0x1652},
{0x0F12, 0x0002},	
{0x0F12, 0x0000},	
{0x002A, 0x15E0},
{0x0F12, 0x0902},	
     
{0x002A, 0x164C},
{0x0F12, 0x0003},	
{0x002A, 0x163E},
{0x0F12, 0x00E5},	
{0x0F12, 0x0098},	
{0x002A, 0x15D4},
{0x0F12, 0x0020},	
{0x0F12, 0xD020},	
{0x002A, 0x169A},
{0x0F12, 0xFF95},	
{0x002A, 0x166A},
{0x0F12, 0x0280},	
{0x002A, 0x1676},	
{0x0F12, 0x03FF},	
{0x0F12, 0x0320},	
{0x002A, 0x16BC},	
{0x0F12, 0x0030},	
{0x002A, 0x16E0},	
{0x0F12, 0x0060},	
{0x002A, 0x16D4},	
{0x0F12, 0x0010},	
{0x002A, 0x1656},	
{0x0F12, 0x0000},	
{0x002A, 0x15E6},
{0x0F12, 0x003C},	
     
{0x0F12, 0x0018},	
{0x0F12, 0x002A},	
{0x0F12, 0x0030},	
{0x0F12, 0x0036},	
{0x0F12, 0x003C},	
{0x0F12, 0x0042},	
{0x0F12, 0x0048},	
{0x0F12, 0x004E},	
{0x0F12, 0x0054},	
{0x0F12, 0x005A},	
{0x0F12, 0x0060},	
{0x0F12, 0x0066},	
{0x0F12, 0x006C},	
{0x0F12, 0x0072},	
{0x0F12, 0x0078},	
{0x0F12, 0x007E},	
{0x0F12, 0x0084},	
{0x0F12, 0x008A},	
{0x0F12, 0x0090},	
{0x0F12, 0x0096},	
{0x0F12, 0x009C},	
{0x0F12, 0x00A2},	
{0x0F12, 0x00A8},	
{0x0F12, 0x00AE},	
{0x0F12, 0x00B4},	
{0x0F12, 0x00BA},	
     
{0x002A, 0x1722},
{0x0F12, 0x8000},	
{0x0F12, 0x0006},	
{0x0F12, 0x3FF0},	
{0x0F12, 0x03E8},	
{0x0F12, 0x0000},	
{0x0F12, 0x0020},	
{0x0F12, 0x0010},	
{0x0F12, 0x0010},	
{0x0F12, 0x0040},	
{0x0F12, 0x0080},	
{0x0F12, 0x00C0},	
{0x0F12, 0x00E0},	
     
{0x002A, 0x028C},
{0x0F12, 0x0003},	

{0x002A, 0x08B4},
{0x0F12, 0x0001},	

{0x002A, 0x08BC},
{0x0F12, 0x00C0},	
{0x0F12, 0x00DF},	
{0x0F12, 0x0100},	
{0x0F12, 0x0125},	
{0x0F12, 0x015F},	
{0x0F12, 0x017C},	
{0x0F12, 0x0194},	
         
{0x002A, 0x08F6},
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4500},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	

{0x0F12, 0x4800},	
{0x0F12, 0x4200},	
{0x0F12, 0x4000},	
{0x0F12, 0x4000},	

{0x002A, 0x08F4},
{0x0F12, 0x0001},	


{0x002A, 0x0F30}, 	
{0x0F12, 0x0001},   	
     
{0x002A, 0x0F2A},	
{0x0F12, 0x0000},	
{0x002A, 0x04E6},	                                      
{0x0F12, 0x077F},	



{0x002A, 0x1484},	
{0x0F12, 0x003C},   	

{0x002A, 0x148A},	
{0x0F12, 0x000F},  	 

{0x002A, 0x0588},
{0x0F12, 0x0000},	
     
{0x002A, 0x0544},	
{0x0F12, 0x0111},  	 
{0x0F12, 0x00EF},  	 

{0x002A, 0x0608},                                	
{0x0F12, 0x0001}, 	
{0x0F12, 0x0001},	
{0x0F12, 0x0800},	
{0x0F12, 0x0100},   	

{0x002A, 0x0610},	
{0x0F12, 0x0001},
{0x0F12, 0x0000},	
{0x0F12, 0x0A3C},	
{0x0F12, 0x0000},	
{0x0F12, 0x0D04},	
{0x0F12, 0x0000},	
{0x0F12, 0x4008},	
{0x0F12, 0x0000},	
{0x0F12, 0x7000},	
{0x0F12, 0x0000},	
{0x0F12, 0x9C00},	
{0x0F12, 0x0000},	
{0x0F12, 0xAD00},	
{0x0F12, 0x0001},	
{0x0F12, 0xF1D4},	
{0x0F12, 0x0002},	
{0x0F12, 0xDC00},	
{0x0F12, 0x0005},	
{0x0F12, 0xDC00},	
{0x0F12, 0x0005},	
     
{0x002A, 0x0638},	
{0x0F12, 0x0001},	
{0x0F12, 0x0000},	
{0x0F12, 0x0A3C},	
{0x0F12, 0x0000},	
{0x0F12, 0x0D05},	
{0x0F12, 0x0000},	
{0x0F12, 0x3408},	
{0x0F12, 0x0000},	
{0x0F12, 0x3408},	
{0x0F12, 0x0000},	
{0x0F12, 0x6810},	
{0x0F12, 0x0000},	
{0x0F12, 0x8214},	
{0x0F12, 0x0000},	
{0x0F12, 0xC350},	
{0x0F12, 0x0000},	
{0x0F12, 0xC350},	
{0x0F12, 0x0000},	
{0x0F12, 0xC350},	
{0x0F12, 0x0000},	

{0x002A, 0x05A2},	
{0x0F12, 0x1000},	

{0x002A, 0x06B8},               	
{0x0F12, 0x452C},               	
{0x0F12, 0x0005},  	 


{0x002A, 0x1492},
{0x0F12, 0x0100},	
{0x0F12, 0x0101},	
{0x0F12, 0x0101},	
{0x0F12, 0x0001},	
{0x0F12, 0x0101},	
{0x0F12, 0x0201},	
{0x0F12, 0x0102},	
{0x0F12, 0x0101},	
{0x0F12, 0x0101},	
{0x0F12, 0x0202},	
{0x0F12, 0x0202},	
{0x0F12, 0x0101},	
{0x0F12, 0x0201},	
{0x0F12, 0x0302},	
{0x0F12, 0x0203},	
{0x0F12, 0x0102},	
{0x0F12, 0x0201},	
{0x0F12, 0x0302},	
{0x0F12, 0x0203},	
{0x0F12, 0x0102},	
{0x0F12, 0x0101},	
{0x0F12, 0x0202},	
{0x0F12, 0x0202},	
{0x0F12, 0x0101},	
{0x0F12, 0x0101},	
{0x0F12, 0x0201},	
{0x0F12, 0x0102},	
{0x0F12, 0x0101},	
{0x0F12, 0x0101},	
{0x0F12, 0x0101},	
{0x0F12, 0x0101},	
{0x0F12, 0x0101},	


{0x002A, 0x145E},
{0x0F12, 0x0580},	
{0x0F12, 0x0428},	
{0x0F12, 0x0780},	

{0x002A, 0x1464},
{0x0F12, 0x0008},	
{0x0F12, 0x0190},	
{0x0F12, 0x00A0},	
{0x0F12, 0x0004},	
{0x0F12, 0x0002},	

{0x002A, 0x144E},			
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0f12, 0x00C2},	
{0x0F12, 0x0002},	
{0x0F12, 0x0001},	
{0x0F12, 0x0074},	
{0x0F12, 0x0001},	

{0x002A, 0x11F0},
{0x0F12, 0x012C},	
{0x0F12, 0x0121},	
{0x0F12, 0x02DF},	
{0x0F12, 0x0314},	
     
{0x002A, 0x120E},
{0x0F12, 0x0000},	
{0x0F12, 0x05FD},	
{0x0F12, 0x036B},	
{0x0F12, 0x0020},	
{0x0F12, 0x001A},	
     
{0x002A, 0x1278},
{0x0F12, 0xFEF7},	
{0x0F12, 0x0021},	
{0x0F12, 0x07D0},	
{0x0F12, 0x07D0},	
{0x0F12, 0x01C8},	
{0x0F12, 0x0096},	
{0x0F12, 0x0004},	

{0x002A, 0x1224},
{0x0F12, 0x0032},	
{0x0F12, 0x001E},	
{0x0F12, 0x00E2},	
{0x0F12, 0x0010},	
{0x0F12, 0x0002},	
{0x002A, 0x2BA4},
{0x0F12, 0x0002},	        
	
{0x002A, 0x11FC},			
{0x0F12, 0x000C},	
     
{0x002A, 0x1208},  
{0x0F12, 0x0020},         
     
{0x002A, 0x101C},
{0x0F12, 0x0360},	
{0x0F12, 0x036C},	
{0x0F12, 0x0320},	
{0x0F12, 0x038A},	
{0x0F12, 0x02E8},	
{0x0F12, 0x0380},	
{0x0F12, 0x02BE},	
{0x0F12, 0x035A},	
{0x0F12, 0x0298},	
{0x0F12, 0x0334},	
{0x0F12, 0x0272},	
{0x0F12, 0x030E},	
{0x0F12, 0x024C},	
{0x0F12, 0x02EA},	
{0x0F12, 0x0230},	
{0x0F12, 0x02CC},	
{0x0F12, 0x0214},	
{0x0F12, 0x02B0},	
{0x0F12, 0x01F8},	
{0x0F12, 0x0294},	
{0x0F12, 0x01DC},	
{0x0F12, 0x0278},	
{0x0F12, 0x01C0},	
{0x0F12, 0x0264},	
{0x0F12, 0x01AA},	
{0x0F12, 0x0250},	
{0x0F12, 0x0196},	
{0x0F12, 0x023C},	
{0x0F12, 0x0180},	
{0x0F12, 0x0228},	
{0x0F12, 0x016C},	
{0x0F12, 0x0214},	
{0x0F12, 0x0168},	
{0x0F12, 0x0200},	
{0x0F12, 0x0172},	
{0x0F12, 0x01EC},	
{0x0F12, 0x019A},	
{0x0F12, 0x01D8},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
     
{0x0F12, 0x0005},	
{0x002A, 0x1070},
{0x0F12, 0x0013},	
{0x002A, 0x1074},
{0x0F12, 0x00EC},	

{0x002A, 0x1078},
{0x0F12, 0x0232},	
{0x0F12, 0x025A},	
{0x0F12, 0x021E},	
{0x0F12, 0x0274},	
{0x0F12, 0x020E},	
{0x0F12, 0x028E},	
{0x0F12, 0x0200},	
{0x0F12, 0x0290},	
{0x0F12, 0x01F4},	
{0x0F12, 0x0286},	
{0x0F12, 0x01E8},	
{0x0F12, 0x027E},	
{0x0F12, 0x01DE},	
{0x0F12, 0x0274},	
{0x0F12, 0x01D2},	
{0x0F12, 0x0268},	
{0x0F12, 0x01D0},	
{0x0F12, 0x025E},	
{0x0F12, 0x01D6},	
{0x0F12, 0x0252},	
{0x0F12, 0x01E2},	
{0x0F12, 0x0248},	
{0x0F12, 0x01F4},	
{0x0F12, 0x021A},	
     
{0x0F12, 0x0004},	
{0x002A, 0x10AC},
{0x0F12, 0x000C},	
{0x002A, 0x10B0},
{0x0F12, 0x01DA},	

{0x002A, 0x10B4},
{0x0F12, 0x0348},	
{0x0F12, 0x03B6},	
{0x0F12, 0x02B8},	
{0x0F12, 0x03B6},	
{0x0F12, 0x0258},	
{0x0F12, 0x038E},	
{0x0F12, 0x0212},	
{0x0F12, 0x0348},	
{0x0F12, 0x01CC},	
{0x0F12, 0x030C},	
{0x0F12, 0x01A2},	
{0x0F12, 0x02D2},	
{0x0F12, 0x0170},	
{0x0F12, 0x02A6},	
{0x0F12, 0x014C},	
{0x0F12, 0x0280},	
{0x0F12, 0x0128},	
{0x0F12, 0x025C},	
{0x0F12, 0x0146},	
{0x0F12, 0x0236},	
{0x0F12, 0x0164},	
{0x0F12, 0x0212},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
     
{0x0F12, 0x0006},	
{0x002A, 0x10E8},
{0x0F12, 0x000B},	
{0x002A, 0x10EC},
{0x0F12, 0x00D2},	

{0x002A, 0x10F0},
{0x0F12, 0x039A},
{0x0F12, 0x0000},	
{0x0F12, 0x00FE},
{0x0F12, 0x0000},	
{0x0F12, 0x2284},
{0x0F12, 0x0000},	        

{0x002A, 0x1434},
{0x0F12, 0x02C1},	
{0x0F12, 0x033A},	
{0x0F12, 0x038A},	
{0x0F12, 0x101A},	
{0x0F12, 0x1075},	
{0x0F12, 0x113D},	
{0x0F12, 0x113F},	
{0x0F12, 0x11AF},	
{0x0F12, 0x11F0},	
{0x0F12, 0x00B2},	
{0x0F12, 0x00B8},	
{0x0F12, 0x00CA},	
{0x0F12, 0x009D},	

{0x002A, 0x13A4},
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFA0},	
{0x0F12, 0xFFEE},	
{0x0F12, 0x0096},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFA0},	
{0x0F12, 0xFFEE},	
{0x0F12, 0x0096},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFE0},	
{0x0F12, 0xFFA0},	
{0x0F12, 0xFFEE},	
{0x0F12, 0x0096},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFF38},	
{0x0F12, 0xFEF2},	
{0x0F12, 0xFE5C},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFF38},	
{0x0F12, 0xFEF2},	
{0x0F12, 0xFE5C},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFF38},	
{0x0F12, 0xFEF2},	
{0x0F12, 0xFE5C},	

{0x0F12, 0xFFC0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0xFFC0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0010},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0010},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0010},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0xFFD0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	


{0x002A, 0x08A6},
{0x0F12, 0x0050},	
{0x0F12, 0x00F0},	
{0x0F12, 0x0110},	
{0x0F12, 0x0120},	
{0x0F12, 0x0130},	
{0x0F12, 0x0162},	
     
{0x0F12, 0x0001},	
     
{0x002A, 0x0898},	
{0x0F12, 0x4800},	
{0x0F12, 0x7000},	
{0x002A, 0x08A0},	
{0x0F12, 0x48D8},	
{0x0F12, 0x7000},	
     
{0x002A, 0x4800},
{0x0F12, 0x0119},	
{0x0F12, 0xFFA9},	
{0x0F12, 0xFF9D},	
{0x0F12, 0xFF30},	
{0x0F12, 0x0130},	
{0x0F12, 0xFF8E},	
{0x0F12, 0xFFF8},	
{0x0F12, 0xFFAC},	
{0x0F12, 0x0137},	
{0x0F12, 0x0087},	
{0x0F12, 0x00D0},	
{0x0F12, 0xFEE3},	
{0x0F12, 0x0162},	
{0x0F12, 0xFF77},	
{0x0F12, 0x00E8},	
{0x0F12, 0xFF40},	
{0x0F12, 0x0114},	
{0x0F12, 0x00F4},	
     
{0x0F12, 0x0119},	
{0x0F12, 0xFFA9},	
{0x0F12, 0xFF9D},	
{0x0F12, 0xFF30},	
{0x0F12, 0x0130},	
{0x0F12, 0xFF8E},	
{0x0F12, 0xFFF8},	
{0x0F12, 0xFFAC},	
{0x0F12, 0x0137},	
{0x0F12, 0x0087},	
{0x0F12, 0x00D0},	
{0x0F12, 0xFEE3},	
{0x0F12, 0x0162},	
{0x0F12, 0xFF77},	
{0x0F12, 0x00E8},	
{0x0F12, 0xFF40},	
{0x0F12, 0x0114},	
{0x0F12, 0x00F4},	
     
{0x0F12, 0x0204},	
{0x0F12, 0xFFB2},	
{0x0F12, 0xFFF5},	
{0x0F12, 0xFEE7},	
{0x0F12, 0x0161},	
{0x0F12, 0xFF10},	
{0x0F12, 0xFFDD},	
{0x0F12, 0xFFE6},	
{0x0F12, 0x01B2},	
{0x0F12, 0x00F2},	
{0x0F12, 0x00CA},	
{0x0F12, 0xFF48},	
{0x0F12, 0x0151},	
{0x0F12, 0xFF50},	
{0x0F12, 0x0147},	
{0x0F12, 0xFF75},	
{0x0F12, 0x01BA},	
{0x0F12, 0x018C},	
     
{0x0F12, 0x0204},	
{0x0F12, 0xFFB2},	
{0x0F12, 0xFFF5},	
{0x0F12, 0xFEF1},	
{0x0F12, 0x014E},	
{0x0F12, 0xFF18},	
{0x0F12, 0xFFE6},	
{0x0F12, 0xFFDD},	
{0x0F12, 0x01B2},	
{0x0F12, 0x00F2},	
{0x0F12, 0x00CA},	
{0x0F12, 0xFF48},	
{0x0F12, 0x0151},	
{0x0F12, 0xFF50},	
{0x0F12, 0x0147},	
{0x0F12, 0xFF75},	
{0x0F12, 0x0187},	
{0x0F12, 0x01BF},	
     
{0x0F12, 0x0204},	
{0x0F12, 0xFFB2},	
{0x0F12, 0xFFF5},	
{0x0F12, 0xFEF1},	
{0x0F12, 0x014E},	
{0x0F12, 0xFF18},	
{0x0F12, 0xFFE6},	
{0x0F12, 0xFFDD},	
{0x0F12, 0x01B2},	
{0x0F12, 0x00F2},	
{0x0F12, 0x00CA},	
{0x0F12, 0xFF48},	
{0x0F12, 0x0151},	
{0x0F12, 0xFF50},	
{0x0F12, 0x0147},	
{0x0F12, 0xFF75},	
{0x0F12, 0x0187},	
{0x0F12, 0x01BF},	
     
{0x0F12, 0x0204},	
{0x0F12, 0xFFB2},	
{0x0F12, 0xFFF5},	
{0x0F12, 0xFEF1},	
{0x0F12, 0x014E},	
{0x0F12, 0xFF18},	
{0x0F12, 0xFFE6},	
{0x0F12, 0xFFDD},	
{0x0F12, 0x01B2},	
{0x0F12, 0x00F2},	
{0x0F12, 0x00CA},	
{0x0F12, 0xFF48},	
{0x0F12, 0x0151},	
{0x0F12, 0xFF50},	
{0x0F12, 0x0147},	
{0x0F12, 0xFF75},	
{0x0F12, 0x0187},	
{0x0F12, 0x01BF},	
     
{0x0F12, 0x01E5},	
{0x0F12, 0xFFA4},	
{0x0F12, 0xFFDC},	
{0x0F12, 0xFE87},	
{0x0F12, 0x013C},	
{0x0F12, 0xFF2A},	
{0x0F12, 0xFFD2},	
{0x0F12, 0xFFDF},	
{0x0F12, 0x0236},	
{0x0F12, 0x00EC},	
{0x0F12, 0x00F8},	
{0x0F12, 0xFF34},	
{0x0F12, 0x01CE},	
{0x0F12, 0xFF83},	
{0x0F12, 0x0195},	
{0x0F12, 0xFEF3},	
{0x0F12, 0x0126},	
{0x0F12, 0x0162},	



{0x002A, 0x0734},
{0x0F12, 0x0001},	
{0x0F12, 0x0003},	
{0x0F12, 0x000F},	
{0x0F12, 0x002B},	
{0x0F12, 0x0069},	
{0x0F12, 0x00D9},	
{0x0F12, 0x0138},	
{0x0F12, 0x0163},	
{0x0F12, 0x0189},	
{0x0F12, 0x01C6},	
{0x0F12, 0x01F8},	
{0x0F12, 0x0222},	
{0x0F12, 0x0249},	
{0x0F12, 0x028D},	
{0x0F12, 0x02C9},	
{0x0F12, 0x0327},	
{0x0F12, 0x0371},	
{0x0F12, 0x03AC},	
{0x0F12, 0x03DD},	
{0x0F12, 0x03FF},	
{0x0F12, 0x0001},	
{0x0F12, 0x0003},	
{0x0F12, 0x000F},	
{0x0F12, 0x002B},	
{0x0F12, 0x0069},	
{0x0F12, 0x00D9},	
{0x0F12, 0x0138},	
{0x0F12, 0x0163},	
{0x0F12, 0x0189},	
{0x0F12, 0x01C6},	
{0x0F12, 0x01F8},	
{0x0F12, 0x0222},	
{0x0F12, 0x0249},	
{0x0F12, 0x028D},	
{0x0F12, 0x02C9},	
{0x0F12, 0x0327},	
{0x0F12, 0x0371},	
{0x0F12, 0x03AC},	
{0x0F12, 0x03DD},	
{0x0F12, 0x03FF},	
{0x0F12, 0x0001},	
{0x0F12, 0x0003},	
{0x0F12, 0x000F},	
{0x0F12, 0x002B},	
{0x0F12, 0x0069},	
{0x0F12, 0x00D9},	
{0x0F12, 0x0138},	
{0x0F12, 0x0163},	
{0x0F12, 0x0189},	
{0x0F12, 0x01C6},	
{0x0F12, 0x01F8},	
{0x0F12, 0x0222},	
{0x0F12, 0x0249},	
{0x0F12, 0x028D},	
{0x0F12, 0x02C9},	
{0x0F12, 0x0327},	
{0x0F12, 0x0371},	
{0x0F12, 0x03AC},	
{0x0F12, 0x03DD},	
{0x0F12, 0x03FF},	

{0x0F12, 0x0001},	
{0x0F12, 0x000B},	
{0x0F12, 0x0019},	
{0x0F12, 0x0036},	
{0x0F12, 0x006F},	
{0x0F12, 0x00D8},	
{0x0F12, 0x0135},	
{0x0F12, 0x015F},	
{0x0F12, 0x0185},	
{0x0F12, 0x01C1},	
{0x0F12, 0x01F3},	
{0x0F12, 0x0220},	
{0x0F12, 0x024A},	
{0x0F12, 0x0291},	
{0x0F12, 0x02D0},	
{0x0F12, 0x032A},	
{0x0F12, 0x036A},	
{0x0F12, 0x039F},	
{0x0F12, 0x03CC},	
{0x0F12, 0x03F9},	
{0x0F12, 0x0001},	
{0x0F12, 0x000B},	
{0x0F12, 0x0019},	
{0x0F12, 0x0036},	
{0x0F12, 0x006F},	
{0x0F12, 0x00D8},	
{0x0F12, 0x0135},	
{0x0F12, 0x015F},	
{0x0F12, 0x0185},	
{0x0F12, 0x01C1},	
{0x0F12, 0x01F3},	
{0x0F12, 0x0220},	
{0x0F12, 0x024A},	
{0x0F12, 0x0291},	
{0x0F12, 0x02D0},	
{0x0F12, 0x032A},	
{0x0F12, 0x036A},	
{0x0F12, 0x039F},	
{0x0F12, 0x03CC},	
{0x0F12, 0x03F9},	
{0x0F12, 0x0001},	
{0x0F12, 0x000B},	
{0x0F12, 0x0019},	
{0x0F12, 0x0036},	
{0x0F12, 0x006F},	
{0x0F12, 0x00D8},	
{0x0F12, 0x0135},	
{0x0F12, 0x015F},	
{0x0F12, 0x0185},	
{0x0F12, 0x01C1},	
{0x0F12, 0x01F3},	
{0x0F12, 0x0220},	
{0x0F12, 0x024A},	
{0x0F12, 0x0291},	
{0x0F12, 0x02D0},	
{0x0F12, 0x032A},	
{0x0F12, 0x036A},	
{0x0F12, 0x039F},	
{0x0F12, 0x03CC},	
{0x0F12, 0x03F9},	
      
{0x002A, 0x0944},	
{0x0F12, 0x0050},	
{0x0F12, 0x00B0},	
{0x0F12, 0x0196},	
{0x0F12, 0x0245},	
{0x0F12, 0x0300},	
     
{0x002A, 0x0938},	
{0x0F12, 0x0000},	
{0x0F12, 0x0014},	
{0x0F12, 0x00D2},	
{0x0F12, 0x0384},	
{0x0F12, 0x07D0},	
{0x0F12, 0x1388},	
     
{0x002A, 0x0976},	
{0x0F12, 0x0070},	
{0x0F12, 0x0005},	
{0x0F12, 0x0000},	
{0x0F12, 0x01CC},	
{0x0F12, 0x01CC},	
{0x0F12, 0x01CC},	
{0x0F12, 0x01CC},	
{0x0F12, 0x01CC},	
{0x0F12, 0x0180},	
{0x0F12, 0x0196},	
     
{0x002A, 0x098C},
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00C0},	
{0x0F12, 0x0064},	
{0x0F12, 0x0384},	
{0x0F12, 0x005F},	
{0x0F12, 0x01F4},	
{0x0F12, 0x0070},	
{0x0F12, 0x0040},	
{0x0F12, 0x00A0},	
{0x0F12, 0x0100},	
{0x0F12, 0x0010},	
{0x0F12, 0x0040},	
{0x0F12, 0x00A0},	
{0x0F12, 0x1430},	
{0x0F12, 0x0201},	
{0x0F12, 0x0204},	
{0x0F12, 0x3604},	
{0x0F12, 0x032A},	
{0x0F12, 0x0403},	
{0x0F12, 0x1B06},	
{0x0F12, 0x6015},	
{0x0F12, 0x00C0},	
{0x0F12, 0x6080},	
{0x0F12, 0x4080},	
{0x0F12, 0x0640},	
{0x0F12, 0x0306},	
{0x0F12, 0x2003},	
{0x0F12, 0xFF01},	
{0x0F12, 0x0000},	
{0x0F12, 0x0400},	
{0x0F12, 0x365A},	
{0x0F12, 0x102A},	
{0x0F12, 0x000B},	
{0x0F12, 0x0600},	
{0x0F12, 0x5A0F},	
{0x0F12, 0x0505},	
{0x0F12, 0x1802},	
{0x0F12, 0x0000},	
{0x0F12, 0x2006},	
{0x0F12, 0x3028},	
{0x0F12, 0x0418},	
{0x0F12, 0x0101},	
{0x0F12, 0x0800},	
{0x0F12, 0x1804},	
{0x0F12, 0x4008},	
{0x0F12, 0x0540},	
{0x0F12, 0x8006},	
{0x0F12, 0x0020},	
{0x0F12, 0x0000},	
{0x0F12, 0x2000},	
{0x0F12, 0x0000},	
{0x0F12, 0x1E10},	
{0x0F12, 0x000B},	
{0x0F12, 0x0607},	
{0x0F12, 0x0005},	
{0x0F12, 0x0607},	
{0x0F12, 0x0705},	
{0x0F12, 0x0206},	
{0x0F12, 0x0304},	
{0x0F12, 0x0309},	
{0x0F12, 0x0305},	
{0x0F12, 0x2006},	
{0x0F12, 0x1320},	
{0x0F12, 0x1014},	
{0x0F12, 0x1010},	
{0x0F12, 0x0C10},	
{0x0F12, 0x1A0C},	
{0x0F12, 0x4A18},	
{0x0F12, 0x0080},	
{0x0F12, 0x0350},	
{0x0F12, 0x0180},	
{0x0F12, 0x0A0A},	
{0x0F12, 0x0101},	
{0x0F12, 0x2A36},	
{0x0F12, 0x6024},	
{0x0F12, 0x2A36},	
{0x0F12, 0xFFFF},	
{0x0F12, 0x0808},	
{0x0F12, 0x0A01},	
{0x0F12, 0x010A},	
{0x0F12, 0x2701},	
{0x0F12, 0x241E},	
{0x0F12, 0x2E60},	
{0x0F12, 0xFF22},	
{0x0F12, 0x40FF},	
{0x0F12, 0x0009},	
{0x0F12, 0x0001},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00C0},	
{0x0F12, 0x0064},	
{0x0F12, 0x0384},	
{0x0F12, 0x0051},	
{0x0F12, 0x01F4},	
{0x0F12, 0x0070},	
{0x0F12, 0x0040},	
{0x0F12, 0x00A0},	
{0x0F12, 0x0100},	
{0x0F12, 0x0010},	
{0x0F12, 0x0060},	
{0x0F12, 0x0100},	
{0x0F12, 0x1430},	
{0x0F12, 0x0201},	
{0x0F12, 0x0204},	
{0x0F12, 0x2404},	
{0x0F12, 0x031B},	
{0x0F12, 0x0103},	
{0x0F12, 0x1205},	
{0x0F12, 0x400D},	
{0x0F12, 0x0080},	
{0x0F12, 0x1980},	
{0x0F12, 0x272E},	
{0x0F12, 0x0629},	
{0x0F12, 0x0306},	
{0x0F12, 0x2003},	
{0x0F12, 0xFF01},	
{0x0F12, 0x0404},	
{0x0F12, 0x0300},	
{0x0F12, 0x245A},	
{0x0F12, 0x1018},	
{0x0F12, 0x000B},	
{0x0F12, 0x0B00},	
{0x0F12, 0x5A0F},	
{0x0F12, 0x0505},	
{0x0F12, 0x1802},	
{0x0F12, 0x0000},	
{0x0F12, 0x2006},	
{0x0F12, 0x3828},	
{0x0F12, 0x0425},	
{0x0F12, 0x0101},	
{0x0F12, 0x0800},	
{0x0F12, 0x1004},	
{0x0F12, 0x4008},	
{0x0F12, 0x0540},	
{0x0F12, 0x8006},	
{0x0F12, 0x0020},	
{0x0F12, 0x0000},	
{0x0F12, 0x2000},	
{0x0F12, 0x0000},	
{0x0F12, 0x1E10},	
{0x0F12, 0x000B},	
{0x0F12, 0x0607},	
{0x0F12, 0x0005},	
{0x0F12, 0x0607},	
{0x0F12, 0x0405},	
{0x0F12, 0x0205},	
{0x0F12, 0x0304},	
{0x0F12, 0x0409},	
{0x0F12, 0x0306},	
{0x0F12, 0x0407},	
{0x0F12, 0x2204},	
{0x0F12, 0x021C},	
{0x0F12, 0x1102},	
{0x0F12, 0x0611},	
{0x0F12, 0x1A02},	
{0x0F12, 0x8018},	
{0x0F12, 0x0080},	
{0x0F12, 0x0374},	
{0x0F12, 0x0180},	
{0x0F12, 0x0A0A},	
{0x0F12, 0x0101},	
{0x0F12, 0x141D},	
{0x0F12, 0x6024},	
{0x0F12, 0x1217},	
{0x0F12, 0xFFFF},	
{0x0F12, 0x0808},	
{0x0F12, 0x0A01},	
{0x0F12, 0x010A},	
{0x0F12, 0x0001},	
{0x0F12, 0x2400},	
{0x0F12, 0x1660},	
{0x0F12, 0xFF10},	
{0x0F12, 0x40FF},	
{0x0F12, 0x0009},	
{0x0F12, 0x0001},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00C0},	
{0x0F12, 0x0064},	
{0x0F12, 0x0384},	
{0x0F12, 0x0043},	
{0x0F12, 0x01F4},	
{0x0F12, 0x0070},	
{0x0F12, 0x0040},	
{0x0F12, 0x00A0},	
{0x0F12, 0x0100},	
{0x0F12, 0x0010},	
{0x0F12, 0x0060},	
{0x0F12, 0x0100},	
{0x0F12, 0x1430},	
{0x0F12, 0x0201},	
{0x0F12, 0x0204},	
{0x0F12, 0x1B04},	
{0x0F12, 0x0312},	
{0x0F12, 0x0003},	
{0x0F12, 0x0C03},	
{0x0F12, 0x2806},	
{0x0F12, 0x0060},	
{0x0F12, 0x1580},	
{0x0F12, 0x2020},	
{0x0F12, 0x0620},	
{0x0F12, 0x0306},	
{0x0F12, 0x2003},	
{0x0F12, 0xFF01},	
{0x0F12, 0x0404},	
{0x0F12, 0x0300},	
{0x0F12, 0x145A},	
{0x0F12, 0x1010},	
{0x0F12, 0x000B},	
{0x0F12, 0x0E00},	
{0x0F12, 0x5A0F},	
{0x0F12, 0x0504},	
{0x0F12, 0x1802},	
{0x0F12, 0x0000},	
{0x0F12, 0x2006},	
{0x0F12, 0x3828},	
{0x0F12, 0x0428},	
{0x0F12, 0x0101},	
{0x0F12, 0x8000},	
{0x0F12, 0x0A04},	
{0x0F12, 0x4008},	
{0x0F12, 0x0540},	
{0x0F12, 0x8006},	
{0x0F12, 0x0020},	
{0x0F12, 0x0000},	
{0x0F12, 0x2000},	
{0x0F12, 0x0000},	
{0x0F12, 0x1E10},	
{0x0F12, 0x000B},	
{0x0F12, 0x0607},	
{0x0F12, 0x0005},	
{0x0F12, 0x0607},	
{0x0F12, 0x0405},	
{0x0F12, 0x0207},	
{0x0F12, 0x0304},	
{0x0F12, 0x0409},	
{0x0F12, 0x0306},	
{0x0F12, 0x0407},	
{0x0F12, 0x2404},	
{0x0F12, 0x0221},	
{0x0F12, 0x1202},	
{0x0F12, 0x0613},	
{0x0F12, 0x1A02},	
{0x0F12, 0x8018},	
{0x0F12, 0x0080},	
{0x0F12, 0x0080},	
{0x0F12, 0x0180},	
{0x0F12, 0x0A0A},	
{0x0F12, 0x0101},	
{0x0F12, 0x121B},	
{0x0F12, 0x6024},	
{0x0F12, 0x0C0C},	
{0x0F12, 0xFFFF},	
{0x0F12, 0x0808},	
{0x0F12, 0x0A01},	
{0x0F12, 0x010A},	
{0x0F12, 0x0001},	
{0x0F12, 0x2400},	
{0x0F12, 0x0460},	
{0x0F12, 0xFF04},	
{0x0F12, 0x40FF},	
{0x0F12, 0x0009},	
{0x0F12, 0x0001},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00C0},	
{0x0F12, 0x0064},	
{0x0F12, 0x0384},	
{0x0F12, 0x0032},	
{0x0F12, 0x01F4},	
{0x0F12, 0x0070},	
{0x0F12, 0x0040},	
{0x0F12, 0x00A0},	
{0x0F12, 0x0100},	
{0x0F12, 0x0010},	
{0x0F12, 0x0060},	
{0x0F12, 0x0100},	
{0x0F12, 0x1430},	
{0x0F12, 0x0201},	
{0x0F12, 0x0204},	
{0x0F12, 0x1504},	
{0x0F12, 0x030F},	
{0x0F12, 0x0003},	
{0x0F12, 0x0902},	
{0x0F12, 0x2004},	
{0x0F12, 0x0050},	
{0x0F12, 0x1140},	
{0x0F12, 0x201C},	
{0x0F12, 0x0620},	
{0x0F12, 0x0306},	
{0x0F12, 0x2003},	
{0x0F12, 0xFF01},	
{0x0F12, 0x0404},	
{0x0F12, 0x0300},	
{0x0F12, 0x145A},	
{0x0F12, 0x1010},	
{0x0F12, 0x000B},	
{0x0F12, 0x1000},	
{0x0F12, 0x5A0F},	
{0x0F12, 0x0503},	
{0x0F12, 0x1802},	
{0x0F12, 0x0000},	
{0x0F12, 0x2006},	
{0x0F12, 0x3C28},	
{0x0F12, 0x042C},	
{0x0F12, 0x0101},	
{0x0F12, 0xFF00},	
{0x0F12, 0x0904},	
{0x0F12, 0x4008},	
{0x0F12, 0x0540},	
{0x0F12, 0x8006},	
{0x0F12, 0x0020},	
{0x0F12, 0x0000},	
{0x0F12, 0x2000},	
{0x0F12, 0x0000},	
{0x0F12, 0x1E10},	
{0x0F12, 0x000B},	
{0x0F12, 0x0607},	
{0x0F12, 0x0005},	
{0x0F12, 0x0607},	
{0x0F12, 0x0405},	
{0x0F12, 0x0206},	
{0x0F12, 0x0304},	
{0x0F12, 0x0409},	
{0x0F12, 0x0305},	
{0x0F12, 0x0406},	
{0x0F12, 0x2804},	
{0x0F12, 0x0228},	
{0x0F12, 0x1402},	
{0x0F12, 0x0618},	
{0x0F12, 0x1A02},	
{0x0F12, 0x8018},	
{0x0F12, 0x0080},	
{0x0F12, 0x0080},	
{0x0F12, 0x0180},	
{0x0F12, 0x0A0A},	
{0x0F12, 0x0101},	
{0x0F12, 0x0F15},	
{0x0F12, 0x6024},	
{0x0F12, 0x0A0A},	
{0x0F12, 0xFFFF},	
{0x0F12, 0x0808},	
{0x0F12, 0x0A01},	
{0x0F12, 0x010A},	
{0x0F12, 0x0001},	
{0x0F12, 0x2400},	
{0x0F12, 0x0260},	
{0x0F12, 0xFF02},	
{0x0F12, 0x40FF},	
{0x0F12, 0x0009},	
{0x0F12, 0x0001},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x00C0},	
{0x0F12, 0x0064},	
{0x0F12, 0x0384},	
{0x0F12, 0x0032},	
{0x0F12, 0x01F4},	
{0x0F12, 0x0070},	
{0x0F12, 0x0040},	
{0x0F12, 0x00A0},	
{0x0F12, 0x0100},	
{0x0F12, 0x0010},	
{0x0F12, 0x0060},	
{0x0F12, 0x0100},	
{0x0F12, 0x1430},	
{0x0F12, 0x0201},	
{0x0F12, 0x0204},	
{0x0F12, 0x0F04},	
{0x0F12, 0x030C},	
{0x0F12, 0x0003},	
{0x0F12, 0x0602},	
{0x0F12, 0x1803},	
{0x0F12, 0x0040},	
{0x0F12, 0x0E20},	
{0x0F12, 0x2018},	
{0x0F12, 0x0620},	
{0x0F12, 0x0306},	
{0x0F12, 0x2003},	
{0x0F12, 0xFF01},	
{0x0F12, 0x0404},	
{0x0F12, 0x0200},	
{0x0F12, 0x145A},	
{0x0F12, 0x1010},	
{0x0F12, 0x000B},	
{0x0F12, 0x1200},	
{0x0F12, 0x5A0F},	
{0x0F12, 0x0502},	
{0x0F12, 0x1802},	
{0x0F12, 0x0000},	
{0x0F12, 0x2006},	
{0x0F12, 0x4028},	
{0x0F12, 0x0430},	
{0x0F12, 0x0101},	
{0x0F12, 0xFF00},	
{0x0F12, 0x0804},	
{0x0F12, 0x4008},	
{0x0F12, 0x0540},	
{0x0F12, 0x8006},	
{0x0F12, 0x0020},	
{0x0F12, 0x0000},	
{0x0F12, 0x2000},	
{0x0F12, 0x0000},	
{0x0F12, 0x1E10},	
{0x0F12, 0x000B},	
{0x0F12, 0x0607},	
{0x0F12, 0x0005},	
{0x0F12, 0x0607},	
{0x0F12, 0x0405},	
{0x0F12, 0x0205},	
{0x0F12, 0x0304},	
{0x0F12, 0x0409},	
{0x0F12, 0x0306},	
{0x0F12, 0x0407},	
{0x0F12, 0x2C04},	
{0x0F12, 0x022C},	
{0x0F12, 0x1402},	
{0x0F12, 0x0618},	
{0x0F12, 0x1A02},	
{0x0F12, 0x8018},	
{0x0F12, 0x0080},	
{0x0F12, 0x0080},	
{0x0F12, 0x0180},	
{0x0F12, 0x0A0A},	
{0x0F12, 0x0101},	
{0x0F12, 0x0C0F},	
{0x0F12, 0x6024},	
{0x0F12, 0x0808},	
{0x0F12, 0xFFFF},	
{0x0F12, 0x0808},	
{0x0F12, 0x0A01},	
{0x0F12, 0x010A},	
{0x0F12, 0x0001},	
{0x0F12, 0x2400},	
{0x0F12, 0x0060},	
{0x0F12, 0xFF00},	
{0x0F12, 0x40FF},	
{0x0F12, 0x0009},	
{0x0F12, 0x0001},	
     
{0x0F12, 0x23CE},	
{0x0F12, 0xFDC8},	
{0x0F12, 0x112E},	
{0x0F12, 0x93A5},	
{0x0F12, 0xFE67},	
{0x0F12, 0x0000},	

{0x002A, 0x01F8},	
{0x0F12, 0x5DC0},	
{0x002A, 0x0212},	                                     
{0x0F12, 0x0000},	
{0x0F12, 0x0002},	
{0x0F12, 0x0002},	


{0x002A, 0x021A},	
{0x0F12, 0x3A98},	
{0x0F12, 0x278D},	
{0x0F12, 0x278D},	
     
{0x0F12, 0x4F1A},	
{0x0F12, 0x278D},	
{0x0F12, 0x278D},	

{0x002A, 0x022C},	
{0x0F12, 0x0001},	

     
{0x002A, 0x02A6},	
{0x0F12, 0x0280},	
{0x0F12, 0x01E0},	
{0x0F12, 0x0005},	
{0x0F12, 0x278D},	
{0x0F12, 0x278D},	
{0x0F12, 0x0100},	
{0x0F12, 0x0300},	
{0x0F12, 0x0002},	
{0x0F12, 0x0000},	
{0x0F12, 0x01E0},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0000},	
{0x0F12, 0x0001},	
{0x0F12, 0x03E8},	
{0x0F12, 0x014A},	
{0x002A, 0x02D0},	
{0x0F12, 0x0002},	
{0x0F12, 0x0002},	

{0x002A, 0x0396},                                     	
{0x0F12, 0x0001},	
{0x0F12, 0x0A00},	
{0x0F12, 0x0780},	
{0x0F12, 0x0005},	
{0x0F12, 0x278D},	
{0x0F12, 0x278D},	
{0x0F12, 0x0100},	
{0x0F12, 0x0300},	
{0x0F12, 0x0002},	
{0x0F12, 0x0070},	
{0x0F12, 0x0810},	
{0x0F12, 0x0900},	
{0x0F12, 0x0001},	
{0x0F12, 0x0000},	
{0x0F12, 0x0002},	
{0x0F12, 0x07d0},	
{0x0F12, 0x07d0},	





{0x0028, 0x7000},//many insert
{0x002A, 0x0266},   
{0x0F12, 0x0000},	
{0x002A, 0x026A},                                    
{0x0F12, 0x0001},	
{0x002A, 0x024E},                                    
{0x0F12, 0x0001},	
{0x002A, 0x0268},                                    
{0x0F12, 0x0001},	
{0x002A, 0x0270},
{0x0F12, 0x0001},	
{0x002A, 0x023E},                                    
{0x0F12, 0x0001},	
{0x0F12, 0x0001},	

{0x002A,	0x01A8},
{0x0F12,	0xAAAA},

{0x0028,	0x147C},
{0x002A,	0x01AA},
{0x0F12,	0x0180},
{0x0028,	0x1482},
{0x002A,	0x01AC},
{0x0F12,	0x0180},

};

#if 0
static struct regval_list sensor_qsxga_regs[] = {
/* capture setting */

{0x002A, 0x0396},                                     	
{0x0F12, 0x0001},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x002A, 0x03AE},                                     	
{0x0F12, 0x0000},
{0x002A, 0x03B4},                                     	
{0x0F12, 0x07D0},
{0x0F12, 0x07D0},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x026E},
{0x0F12, 0x0000},
{0x0F12, 0x0001},
{0x002A, 0x0242},
{0x0F12, 0x0001},
{0x002A, 0x024E},
{0x0F12, 0x0001},
{0x002A, 0x0244},
{0x0F12, 0x0001},

{0xffff, 0x00c8}, 
};


#else
static struct regval_list sensor_qsxga_regs[] = {
/* capture setting */

{0x002A, 0x0396},                                     	
{0x0F12, 0x0001},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x002A, 0x03AE},                                     	
{0x0F12, 0x0000},
{0x002A, 0x03B4},      
{0x0F12, 0x0535},
{0x0F12, 0x0535},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x026E},
{0x0F12, 0x0000},
{0x0F12, 0x0001},
{0x002A, 0x0242},
{0x0F12, 0x0001},
{0x002A, 0x024E},
{0x0F12, 0x0001},
{0x002A, 0x0244},
{0x0F12, 0x0001},

{0xffff, 0x00c8}, 
};
#endif

static struct regval_list sensor_qxga_regs[] = {
/* capture setting */

{0x002A, 0x0396},                                     	
{0x0F12, 0x0001},
{0x0F12, 0x0800},
{0x0F12, 0x0600},
{0x002A, 0x03AE},                                     	
{0x0F12, 0x0000},
{0x002A, 0x03B4},                                     	
{0x0F12, 0x0535},
{0x0F12, 0x0535},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x026E},
{0x0F12, 0x0000},
{0x0F12, 0x0001},
{0x002A, 0x0242},
{0x0F12, 0x0001},
{0x002A, 0x024E},
{0x0F12, 0x0001},
{0x002A, 0x0244},
{0x0F12, 0x0001},

{0xffff, 0x00c8}, 
};                                      


static struct regval_list sensor_1080p_regs[] = {
/* preview setting */

{0x002A, 0x18AC},
{0x0F12, 0x0060},
{0x0F12, 0x0060},
{0x0F12, 0x05C0},
{0x0F12, 0x0A96},

{0x002A, 0x0250},
{0x0F12, 0x0780},
{0x0F12, 0x0438},
{0x0F12, 0x014E},
{0x0F12, 0x01B0},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0010},
{0x0F12, 0x000C},

{0x002A, 0x0494},
{0x0F12, 0x0780},
{0x0F12, 0x0438},
{0x0F12, 0x0000},
{0x0F12, 0x0000},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0000},
{0x0F12, 0x0000},

{0x002A, 0x0262},
{0x0F12, 0x0001},
{0x0F12, 0x0001},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02A6},
{0x0F12, 0x0780},
{0x0F12, 0x0438},
{0x002A, 0x02BC},
{0x0F12, 0x0001},
{0x0F12, 0x0001},
{0x0F12, 0x0000},
{0x0F12, 0x029A},
{0x0F12, 0x029A},

{0x002A, 0x022C},	
{0x0F12, 0x0001},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x0266},
{0x0f12, 0x0000},
{0x002A, 0x026A},
{0x0F12, 0x0001},
{0x002A, 0x0268},
{0x0F12, 0x0001},
{0x002A, 0x026E},                                          
{0x0f12, 0x0000},      
{0x002A, 0x026A},	                                         
{0x0F12, 0x0001},
{0x002A, 0x0270},	                                         
{0x0F12, 0x0001},
    		
{0x002A, 0x024E},
{0x0F12, 0x0001},
{0x002A, 0x023E},
{0x0F12, 0x0001},
{0x0F12, 0x0001},


{0xffff, 0x00c8}, 
};

static struct regval_list sensor_720p_regs[] = {
/* preview setting */

{0x002A, 0x18AC},
{0x0F12, 0x0060},
{0x0F12, 0x0060},
{0x0F12, 0x05C0},
{0x0F12, 0x0A96},

{0x002A, 0x0250},
{0x0F12, 0x0A00},
{0x0F12, 0x05A0},
{0x0F12, 0x0010},
{0x0F12, 0x00FC},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0010},
{0x0F12, 0x000C},

{0x002A, 0x0494},
{0x0F12, 0x0A00},
{0x0F12, 0x05A0},
{0x0F12, 0x0000},
{0x0F12, 0x0000},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0000},
{0x0F12, 0x0000},

{0x002A, 0x0262},
{0x0F12, 0x0001},
{0x0F12, 0x0001},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02A6},
{0x0F12, 0x0500},
{0x0F12, 0x02D0},
{0x002A, 0x02BC},
{0x0F12, 0x0000},
{0x0F12, 0x0001},
{0x0F12, 0x0001},
{0x0F12, 0x014D},
{0x0F12, 0x014D},

{0x002A, 0x022C},	
{0x0F12, 0x0001},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x0266},
{0x0f12, 0x0000},
{0x002A, 0x026A},
{0x0F12, 0x0001},
{0x002A, 0x0268},	                                         
{0x0F12, 0x0001},
{0x002A, 0x026E},                                          
{0x0f12, 0x0000},      
{0x002A, 0x026A},	                                         
{0x0F12, 0x0001},
{0x002A, 0x0270},	                                         
{0x0F12, 0x0001},
    		
{0x002A, 0x024E},
{0x0F12, 0x0001},
{0x002A, 0x023E},
{0x0F12, 0x0001},
{0x0F12, 0x0001},

{0xffff, 0x00c8}, 
};

static struct regval_list sensor_vga_regs[] = {
#if 0 
/* preview setting */

{0x002A, 0x18AC},
{0x0F12, 0x0060},
{0x0F12, 0x0060},
{0x0F12, 0x05C0},
{0x0F12, 0x05C0},

{0x002A, 0x0250},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0010},
{0x0F12, 0x000C},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0010},
{0x0F12, 0x000C},

{0x002A, 0x0494},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0000},
{0x0F12, 0x0000},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0000},
{0x0F12, 0x0000},

{0x002A, 0x0262},
{0x0F12, 0x0001},
{0x0F12, 0x0001},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02A6},	
{0x0F12, 0x0280},
{0x0F12, 0x01E0},
{0x002A, 0x02BC},	
{0x0F12, 0x0000},
{0x0F12, 0x0000},
{0x0F12, 0x0001},
{0x0F12, 0x0535},
{0x0F12, 0x014D},

{0x002A, 0x022C},	
{0x0F12, 0x0001},

{0xFCFC, 0xD000},
{0x0028, 0x7000},                                		                               		
{0x002A, 0x0266},   
{0x0f12, 0x0000},
{0x002A, 0x026A},	                                   
{0x0F12, 0x0001},
{0x002A, 0x0268},	                                         
{0x0F12, 0x0001},
{0x002A, 0x026E},                                          
{0x0f12, 0x0000},      
{0x002A, 0x026A},	                                         
{0x0F12, 0x0001},
{0x002A, 0x0270},	                                         
{0x0F12, 0x0001},
    		
{0x002A, 0x024E},	                                   
{0x0F12, 0x0001},
{0x002A, 0x023E},	                                   
{0x0F12, 0x0001},
{0x0F12, 0x0001},

{0xffff, 0x00c8}, 
#else		
/* preview setting */

{0x002A, 0x18AC},
{0x0F12, 0x0060},
{0x0F12, 0x0060},
{0x0F12, 0x05C0},
{0x0F12, 0x05C0},

{0x002A, 0x0250},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0010},
{0x0F12, 0x000C},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0010},
{0x0F12, 0x000C},

{0x002A, 0x0494},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0000},
{0x0F12, 0x0000},
{0x0F12, 0x0A00},
{0x0F12, 0x0780},
{0x0F12, 0x0000},
{0x0F12, 0x0000},

{0x002A, 0x0262},
{0x0F12, 0x0001},
{0x0F12, 0x0001},

{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02A6},	
{0x0F12, 0x0280},
{0x0F12, 0x01E0},
{0x002A, 0x02BC},	
{0x0F12, 0x0000},
{0x0F12, 0x0002},
{0x0F12, 0x0001},
{0x0F12, 0x014D},
{0x0F12, 0x0000},

{0x0028, 0x7000},
{0x002A, 0x0266},
{0x0f12, 0x0000},
{0x002A, 0x026A},
{0x0F12, 0x0001},
{0x002A, 0x0268},
{0x0F12, 0x0001},
{0x002A, 0x026E},
{0x0f12, 0x0000},
{0x002A, 0x026A},
{0x0F12, 0x0001},
{0x002A, 0x0270},
{0x0F12, 0x0001},

{0x002A, 0x024E},
{0x0F12, 0x0001},
{0x002A, 0x023E},
{0x0F12, 0x0001},
{0x0F12, 0x0001},

#endif

};

#if 0
static struct regval_list sensor_oe_disable_regs[] = {
};
#endif


#if 0
static struct regval_list sensor_af_fw_regs[] = {
};
#endif

static struct regval_list sensor_ae_awb_lockon_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x2C5E},
{0x0F12, 0x0000},
};

static struct regval_list sensor_ae_awb_lockoff_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x2C5E},
{0x0F12, 0x0001},
};

static struct regval_list sensor_af_single_trig_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x028E},
{0x0F12, 0x0000},
{0x002A, 0x028C},
{0x0F12, 0x0005},
};

static struct regval_list sensor_af_continueous_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x028E},
{0x0F12, 0x0000},
{0x002A, 0x028C},
{0x0F12, 0x0006},
};

static struct regval_list sensor_af_infinity_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x028E},
{0x0F12, 0x0000},
{0x002A, 0x028C},
{0x0F12, 0x0004},


{0x002A, 0x1648},
{0x0F12, 0x9002},
};




/*
 * The white balance settings
 * Here only tune the R G B channel gain. 
 * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
 */
static struct regval_list sensor_wb_manual[] = {  
};

static struct regval_list sensor_wb_auto_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x04E6},
{0x0F12, 0x077F},
};

static struct regval_list sensor_wb_incandescence_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x04E6},
{0x0F12, 0x0777},
{0x002A, 0x04BA},
{0x0F12, 0x0430},
{0x002A, 0x04BE},
{0x0F12, 0x03D0},
{0x002A, 0x04C2},
{0x0F12, 0x09F0},
{0x002A, 0x04C6},
{0x0F12, 0x0001},
};

static struct regval_list sensor_wb_fluorescent_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x04E6}, 
{0x0F12, 0x0777},
{0x002A, 0x04BA},
{0x0F12, 0x06C0},
{0x002A, 0x04BE},
{0x0F12, 0x0440},
{0x002A, 0x04C2},
{0x0F12, 0x07A0},
{0x002A, 0x04C6},
{0x0F12, 0x0001},
};

static struct regval_list sensor_wb_tungsten_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x04E6},
{0x0F12, 0x0777},
{0x002A, 0x04BA},
{0x0F12, 0x0540},
{0x002A, 0x04BE},
{0x0F12, 0x03D0},
{0x002A, 0x04C2},
{0x0F12, 0x08F0},
{0x002A, 0x04C6},
{0x0F12, 0x0001},
};

static struct regval_list sensor_wb_horizon[] = { 
};

static struct regval_list sensor_wb_daylight_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x04E6},
{0x0F12, 0x0777},
{0x002A, 0x04BA},
{0x0F12, 0x0620},
{0x002A, 0x04BE},
{0x0F12, 0x03D0},
{0x002A, 0x04C2},
{0x0F12, 0x0580},
{0x002A, 0x04C6},
{0x0F12, 0x0001},
};

static struct regval_list sensor_wb_flash[] = { 
};

static struct regval_list sensor_wb_cloud_regs[] = {	
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x04E6},
{0x0F12, 0x0777},
{0x002A, 0x04BA},
{0x0F12, 0x06D0},
{0x002A, 0x04BE},
{0x0F12, 0x03D0},
{0x002A, 0x04C2},
{0x0F12, 0x0520},
{0x002A, 0x04C6},
{0x0F12, 0x0001},
};

static struct regval_list sensor_wb_shade[] = { 
};

static struct cfg_array sensor_wb[] = {
  { 
  	.regs = sensor_wb_manual,            
    .size = ARRAY_SIZE(sensor_wb_manual),
  },
  {
  	.regs = sensor_wb_auto_regs,         
    .size = ARRAY_SIZE(sensor_wb_auto_regs),
  },
  {
  	.regs = sensor_wb_incandescence_regs,
    .size = ARRAY_SIZE(sensor_wb_incandescence_regs),
  },
  {
  	.regs = sensor_wb_fluorescent_regs,  
    .size = ARRAY_SIZE(sensor_wb_fluorescent_regs),
  },
  {
  	.regs = sensor_wb_tungsten_regs,     
    .size = ARRAY_SIZE(sensor_wb_tungsten_regs),
  },
  {
  	.regs = sensor_wb_horizon,           
    .size = ARRAY_SIZE(sensor_wb_horizon),
  },  
  {
  	.regs = sensor_wb_daylight_regs,     
    .size = ARRAY_SIZE(sensor_wb_daylight_regs),
  },
  {
  	.regs = sensor_wb_flash,             
    .size = ARRAY_SIZE(sensor_wb_flash),
  },
  {
  	.regs = sensor_wb_cloud_regs,        
    .size = ARRAY_SIZE(sensor_wb_cloud_regs),
  },
  {
  	.regs = sensor_wb_shade,             
    .size = ARRAY_SIZE(sensor_wb_shade),
  },
};
 
 
/*
 * The color effect settings
 */
static struct regval_list sensor_colorfx_none_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023C},
{0x0F12, 0x0000},
};

static struct regval_list sensor_colorfx_bw_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023C},
{0x0F12, 0x0001},
};

static struct regval_list sensor_colorfx_sepia_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023C},
{0x0F12, 0x0004},
};

static struct regval_list sensor_colorfx_negative_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023C},
{0x0F12, 0x0003},
};

static struct regval_list sensor_colorfx_emboss_regs[] = {

};

static struct regval_list sensor_colorfx_sketch_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023C},
{0x0F12, 0x0009},
};

static struct regval_list sensor_colorfx_sky_blue_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023C},
{0x0F12, 0x0007},
};

static struct regval_list sensor_colorfx_grass_green_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023C},
{0x0F12, 0x0009},
};

static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
};

static struct regval_list sensor_colorfx_vivid_regs[] = {
};

static struct regval_list sensor_colorfx_aqua_regs[] = {
};

static struct regval_list sensor_colorfx_art_freeze_regs[] = {
};

static struct regval_list sensor_colorfx_silhouette_regs[] = {
};

static struct regval_list sensor_colorfx_solarization_regs[] = {
};

static struct regval_list sensor_colorfx_antique_regs[] = {
};

static struct regval_list sensor_colorfx_set_cbcr_regs[] = {
};

static struct cfg_array sensor_colorfx[] = {
  {
  	.regs = sensor_colorfx_none_regs,        
    .size = ARRAY_SIZE(sensor_colorfx_none_regs),
  },
  {
  	.regs = sensor_colorfx_bw_regs,          
    .size = ARRAY_SIZE(sensor_colorfx_bw_regs),
  },
  {
  	.regs = sensor_colorfx_sepia_regs,       
    .size = ARRAY_SIZE(sensor_colorfx_sepia_regs),
  },
  {
  	.regs = sensor_colorfx_negative_regs,    
    .size = ARRAY_SIZE(sensor_colorfx_negative_regs),
  },
  {
  	.regs = sensor_colorfx_emboss_regs,      
    .size = ARRAY_SIZE(sensor_colorfx_emboss_regs),
  },
  {
  	.regs = sensor_colorfx_sketch_regs,      
    .size = ARRAY_SIZE(sensor_colorfx_sketch_regs),
  },
  {
  	.regs = sensor_colorfx_sky_blue_regs,    
    .size = ARRAY_SIZE(sensor_colorfx_sky_blue_regs),
  },
  {
  	.regs = sensor_colorfx_grass_green_regs, 
    .size = ARRAY_SIZE(sensor_colorfx_grass_green_regs),
  },
  {
  	.regs = sensor_colorfx_skin_whiten_regs, 
    .size = ARRAY_SIZE(sensor_colorfx_skin_whiten_regs),
  },
  {
  	.regs = sensor_colorfx_vivid_regs,       
    .size = ARRAY_SIZE(sensor_colorfx_vivid_regs),
  },
  {
  	.regs = sensor_colorfx_aqua_regs,        
    .size = ARRAY_SIZE(sensor_colorfx_aqua_regs),
  },
  {
  	.regs = sensor_colorfx_art_freeze_regs,  
    .size = ARRAY_SIZE(sensor_colorfx_art_freeze_regs),
  },
  {
  	.regs = sensor_colorfx_silhouette_regs,  
    .size = ARRAY_SIZE(sensor_colorfx_silhouette_regs),
  },
  {
  	.regs = sensor_colorfx_solarization_regs,
    .size = ARRAY_SIZE(sensor_colorfx_solarization_regs),
  },
  {
  	.regs = sensor_colorfx_antique_regs,     
    .size = ARRAY_SIZE(sensor_colorfx_antique_regs),
  },
  {
  	.regs = sensor_colorfx_set_cbcr_regs,    
    .size = ARRAY_SIZE(sensor_colorfx_set_cbcr_regs),
  },
};

/*
 * The power frequency
 */
static struct regval_list sensor_flicker_50hz_regs[] = {
{0x002A, 0x04E6},
{0x0F12, 0x075F},
{0x002a, 0x04d6},
{0x0F12, 0x0001},
{0x0F12, 0x0001},
};

static struct regval_list sensor_flicker_60hz_regs[] = {
{0x002A, 0x04E6},														
{0x0F12, 0x075F},
{0x002a, 0x04d6},
{0x0f12, 0x0002},
{0x0F12, 0x0001},
};

/*
 * The brightness setttings
 */
static struct regval_list sensor_brightness_neg4_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x0024},
};

static struct regval_list sensor_brightness_neg3_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x002A},
};

static struct regval_list sensor_brightness_neg2_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x0030},
};

static struct regval_list sensor_brightness_neg1_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x0036},
};

static struct regval_list sensor_brightness_zero_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x003C},
};

static struct regval_list sensor_brightness_pos1_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x0047},
};

static struct regval_list sensor_brightness_pos2_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x0052},
};

static struct regval_list sensor_brightness_pos3_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x0057},
};

static struct regval_list sensor_brightness_pos4_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x1484},
{0x0F12, 0x0068},
};

static struct cfg_array sensor_brightness[] = {
  {
  	.regs = sensor_brightness_neg4_regs,
  	.size = ARRAY_SIZE(sensor_brightness_neg4_regs),
  },
  {
  	.regs = sensor_brightness_neg3_regs,
  	.size = ARRAY_SIZE(sensor_brightness_neg3_regs),
  },
  {
  	.regs = sensor_brightness_neg2_regs,
  	.size = ARRAY_SIZE(sensor_brightness_neg2_regs),
  },
  {
  	.regs = sensor_brightness_neg1_regs,
  	.size = ARRAY_SIZE(sensor_brightness_neg1_regs),
  },
  {
  	.regs = sensor_brightness_zero_regs,
  	.size = ARRAY_SIZE(sensor_brightness_zero_regs),
  },
  {
  	.regs = sensor_brightness_pos1_regs,
  	.size = ARRAY_SIZE(sensor_brightness_pos1_regs),
  },
  {
  	.regs = sensor_brightness_pos2_regs,
  	.size = ARRAY_SIZE(sensor_brightness_pos2_regs),
  },
  {
  	.regs = sensor_brightness_pos3_regs,
  	.size = ARRAY_SIZE(sensor_brightness_pos3_regs),
  },
  {
  	.regs = sensor_brightness_pos4_regs,
  	.size = ARRAY_SIZE(sensor_brightness_pos4_regs),
  },
};

/*
 * The contrast setttings
 */
static struct regval_list sensor_contrast_neg4_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0xFF80},  
};

static struct regval_list sensor_contrast_neg3_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0xFFA0},  
};

static struct regval_list sensor_contrast_neg2_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0xFFC0},  
};

static struct regval_list sensor_contrast_neg1_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0xFFE0},  
};

static struct regval_list sensor_contrast_zero_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0x0000},  
};

static struct regval_list sensor_contrast_pos1_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0x0020},  
};

static struct regval_list sensor_contrast_pos2_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0x0040},  
};

static struct regval_list sensor_contrast_pos3_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0x0060},  
};

static struct regval_list sensor_contrast_pos4_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0232},
{0x0F12, 0x0080},  
};

static struct cfg_array sensor_contrast[] = {
  {
  	.regs = sensor_contrast_neg4_regs,
  	.size = ARRAY_SIZE(sensor_contrast_neg4_regs),
  },
  {
  	.regs = sensor_contrast_neg3_regs,
  	.size = ARRAY_SIZE(sensor_contrast_neg3_regs),
  },
  {
  	.regs = sensor_contrast_neg2_regs,
  	.size = ARRAY_SIZE(sensor_contrast_neg2_regs),
  },
  {
  	.regs = sensor_contrast_neg1_regs,
  	.size = ARRAY_SIZE(sensor_contrast_neg1_regs),
  },
  {
  	.regs = sensor_contrast_zero_regs,
  	.size = ARRAY_SIZE(sensor_contrast_zero_regs),
  },
  {
  	.regs = sensor_contrast_pos1_regs,
  	.size = ARRAY_SIZE(sensor_contrast_pos1_regs),
  },
  {
  	.regs = sensor_contrast_pos2_regs,
  	.size = ARRAY_SIZE(sensor_contrast_pos2_regs),
  },
  {
  	.regs = sensor_contrast_pos3_regs,
  	.size = ARRAY_SIZE(sensor_contrast_pos3_regs),
  },
  {
  	.regs = sensor_contrast_pos4_regs,
  	.size = ARRAY_SIZE(sensor_contrast_pos4_regs),
  },
};

/*
 * The saturation setttings
 */
static struct regval_list sensor_saturation_neg4_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0xFF80},  
};

static struct regval_list sensor_saturation_neg3_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0xFFA0},  
};

static struct regval_list sensor_saturation_neg2_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0xFFC0},  
};

static struct regval_list sensor_saturation_neg1_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0xFFE0},  
};

static struct regval_list sensor_saturation_zero_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0x0000},  
};

static struct regval_list sensor_saturation_pos1_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0x0020},  
};

static struct regval_list sensor_saturation_pos2_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0x0040},  
};

static struct regval_list sensor_saturation_pos3_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0x0060},  
};

static struct regval_list sensor_saturation_pos4_regs[] = {
{0x0028, 0x7000},
{0x002A, 0x0234},
{0x0F12, 0x0080},  
};

static struct cfg_array sensor_saturation[] = {
  {
  	.regs = sensor_saturation_neg4_regs,
  	.size = ARRAY_SIZE(sensor_saturation_neg4_regs),
  },
  {
  	.regs = sensor_saturation_neg3_regs,
  	.size = ARRAY_SIZE(sensor_saturation_neg3_regs),
  },
  {
  	.regs = sensor_saturation_neg2_regs,
  	.size = ARRAY_SIZE(sensor_saturation_neg2_regs),
  },
  {
  	.regs = sensor_saturation_neg1_regs,
  	.size = ARRAY_SIZE(sensor_saturation_neg1_regs),
  },
  {
  	.regs = sensor_saturation_zero_regs,
  	.size = ARRAY_SIZE(sensor_saturation_zero_regs),
  },
  {
  	.regs = sensor_saturation_pos1_regs,
  	.size = ARRAY_SIZE(sensor_saturation_pos1_regs),
  },
  {
  	.regs = sensor_saturation_pos2_regs,
  	.size = ARRAY_SIZE(sensor_saturation_pos2_regs),
  },
  {
  	.regs = sensor_saturation_pos3_regs,
  	.size = ARRAY_SIZE(sensor_saturation_pos3_regs),
  },
  {
  	.regs = sensor_saturation_pos4_regs,
  	.size = ARRAY_SIZE(sensor_saturation_pos4_regs),
  },
};

/*
 * The exposure target setttings
 */
static struct regval_list sensor_ev_neg4_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x0080},  
};

static struct regval_list sensor_ev_neg3_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x00A0},  
};

static struct regval_list sensor_ev_neg2_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x00C0},  
};

static struct regval_list sensor_ev_neg1_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x00E0},  
};                     

static struct regval_list sensor_ev_zero_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x0100},  
};

static struct regval_list sensor_ev_pos1_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x0120},  
};

static struct regval_list sensor_ev_pos2_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x0140},  
};

static struct regval_list sensor_ev_pos3_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x0160},  
};

static struct regval_list sensor_ev_pos4_regs[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x023A},
{0x0F12, 0x0180},  
};

static struct cfg_array sensor_ev[] = {
  {
  	.regs = sensor_ev_neg4_regs,
  	.size = ARRAY_SIZE(sensor_ev_neg4_regs),
  },
  {
  	.regs = sensor_ev_neg3_regs,
  	.size = ARRAY_SIZE(sensor_ev_neg3_regs),
  },
  {
  	.regs = sensor_ev_neg2_regs,
  	.size = ARRAY_SIZE(sensor_ev_neg2_regs),
  },
  {
  	.regs = sensor_ev_neg1_regs,
  	.size = ARRAY_SIZE(sensor_ev_neg1_regs),
  },
  {
  	.regs = sensor_ev_zero_regs,
  	.size = ARRAY_SIZE(sensor_ev_zero_regs),
  },
  {
  	.regs = sensor_ev_pos1_regs,
  	.size = ARRAY_SIZE(sensor_ev_pos1_regs),
  },
  {
  	.regs = sensor_ev_pos2_regs,
  	.size = ARRAY_SIZE(sensor_ev_pos2_regs),
  },
  {
  	.regs = sensor_ev_pos3_regs,
  	.size = ARRAY_SIZE(sensor_ev_pos3_regs),
  },
  {
  	.regs = sensor_ev_pos4_regs,
  	.size = ARRAY_SIZE(sensor_ev_pos4_regs),
  },
};


/*
 * Here we'll try to encapsulate the changes for just the output
 * video format.
 * 
 */
static struct regval_list sensor_fmt_mipi_yuv422[] = {


{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02B4},	
{0x0F12, 0x0040},
{0x002A, 0x03A6},	
{0x0F12, 0x0040},





};

#if 0
static struct regval_list sensor_fmt_yuv422_yuyv[] = {	
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02B4},	
{0x0F12, 0x0040},
{0x002A, 0x03A6},	
{0x0F12, 0x0040},

   
};

static struct regval_list sensor_fmt_yuv422_yvyu[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02B4},	
{0x0F12, 0x0060},
{0x002A, 0x03A6},	
{0x0F12, 0x0060},

};

static struct regval_list sensor_fmt_yuv422_vyuy[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02B4},	
{0x0F12, 0x0070},
{0x002A, 0x03A6},	
{0x0F12, 0x0070},

};

static struct regval_list sensor_fmt_yuv422_uyvy[] = {
{0xFCFC, 0xD000},
{0x0028, 0x7000},
{0x002A, 0x02B4},	
{0x0F12, 0x0050},
{0x002A, 0x03A6},	
{0x0F12, 0x0050},

};
#endif



/*
 * Low-level register I/O.
 *
 */


/*
 * On most platforms, we'd rather do straight i2c I/O.
 */
static int sensor_read(struct v4l2_subdev *sd, unsigned short reg,
    unsigned short *value)
{
	int ret=0;
	int cnt=0;
	
  ret = cci_read_a16_d16(sd,reg,value);
  while(ret!=0&&cnt<2)
  {
  	ret = cci_read_a16_d16(sd,reg,value);
  	cnt++;
  }
  if(cnt>0)
  	vfe_dev_dbg("sensor read retry=%d\n",cnt);
  
  return ret;
}

static int sensor_write(struct v4l2_subdev *sd, unsigned short reg,
    unsigned short value)
{
	int ret=0;
	int cnt=0;
	
  ret = cci_write_a16_d16(sd,reg,value);
  while(ret!=0&&cnt<2)
  {
  	ret = cci_write_a16_d16(sd,reg,value);
  	cnt++;
  }
  if(cnt>0)
  	vfe_dev_dbg("sensor write retry=%d\n",cnt);
  
  return ret;
}

/*
 * Write a list of register settings;
 */
static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *regs, int array_size)
{
	int i=0;
	
  if(!regs)
  	return -EINVAL;
  
  while(i<array_size)
  {
    if(regs->addr == REG_DLY) {
      msleep(regs->data);
    } 
    else {  
      LOG_ERR_RET(sensor_write(sd, regs->addr, regs->data))
    }
    i++;
    regs++;
  }
  return 0;
}

static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);

	*value = info->hflip;
	return 0;
}

static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	unsigned short pre_val,cap_val;
	struct regval_list regs[] = {
		
		{0xFCFC, 0xD000},
		{0x0028, 0x7000},
		{0x002A, 0x0266},
		{0x0f12, 0x0000},
		{0x002A, 0x026A},
		{0x0F12, 0x0001},
		{0x002A, 0x024E},
		{0x0F12, 0x0001},
		{0x002A, 0x0268},
		{0x0F12, 0x0001},
		{0x002A, 0x023E},
		{0x0F12, 0x0001},
		{0x0F12, 0x0001},
  };

	if(info->hflip == value)
		return 0;

	sensor_write(sd, 0x002c , 0x7000);
	sensor_write(sd, 0x002e , 0x02d0);
	sensor_read(sd, 0x0f12, &pre_val);
	sensor_read(sd, 0x0f12, &cap_val);
	sensor_write(sd, 0x0028, 0x7000);
	sensor_write(sd, 0x002a, 0x02d0);
	
	switch (value) {
		case 0:
		  pre_val &= 0xfa;
		  cap_val &= 0xfa;
			break;
		case 1:
		  pre_val |= 0x05;
		  cap_val |= 0x05;
			break;
		default:
			return -EINVAL;
	}
	
	sensor_write(sd, 0x0f12, pre_val);
  sensor_write(sd, 0x0f12, cap_val);
  
	ret = sensor_write_array(sd, regs, ARRAY_SIZE(regs));
	if (ret < 0) {
		vfe_dev_err("sensor_write err at sensor_s_hflip!\n");
		return ret;
	}

	info->hflip = value;
	
	return 0;
}

static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);

	*value = info->vflip;
	return 0;
}

static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	unsigned short pre_val,cap_val;
	struct regval_list regs[] = {
		
		{0xFCFC, 0xD000},
		{0x0028, 0x7000},
		{0x002A, 0x0266},
		{0x0f12, 0x0000},
		{0x002A, 0x026A},
		{0x0F12, 0x0001},
		{0x002A, 0x024E},
		{0x0F12, 0x0001},
		{0x002A, 0x0268},
		{0x0F12, 0x0001},
		{0x002A, 0x023E},
		{0x0F12, 0x0001},
		{0x0F12, 0x0001},
  };

	if(info->vflip == value)
		return 0;
	
	sensor_write(sd, 0x0028, 0x7000);
	sensor_write(sd, 0x002a, 0x02d0);
	sensor_write(sd, 0x002c , 0x7000);
	sensor_write(sd, 0x002e , 0x02d0);
	sensor_read(sd, 0x0f12, &pre_val);
	sensor_read(sd, 0x0f12, &cap_val);
	
	switch (value) {
		case 0:
		  pre_val &= 0xf5;
		  cap_val &= 0xf5;
			break;
		case 1:
		  pre_val |= 0x0A;
		  cap_val |= 0x0A;
			break;
		default:
			return -EINVAL;
	}

	sensor_write(sd, 0x0f12, pre_val);
  sensor_write(sd, 0x0f12, cap_val);

	ret = sensor_write_array(sd, regs, ARRAY_SIZE(regs));
	if (ret < 0) {
		vfe_dev_err("sensor_write err at sensor_s_vflip!\n");
		return ret;
	}

	info->vflip = value;
	
	return 0;
}

/* stuff about exposure when capturing image */

static int sensor_set_exposure(struct v4l2_subdev *sd)
{	
	return 0;
}

/* stuff about auto focus */
static int sensor_download_af_fw(struct v4l2_subdev *sd)
{
  return 0;
}

static int sensor_ae_awb_lockon(struct v4l2_subdev *sd)
{
	int ret;
	
	ret = sensor_write_array(sd, sensor_ae_awb_lockon_regs , ARRAY_SIZE(sensor_ae_awb_lockon_regs));
	if(ret < 0)
		vfe_dev_err("sensor_ae_awb_lockon error!\n"); 
	
	return ret;
};

static int sensor_ae_awb_lockoff(struct v4l2_subdev *sd)
{
	int ret;
	
	ret = sensor_write_array(sd, sensor_ae_awb_lockoff_regs , ARRAY_SIZE(sensor_ae_awb_lockoff_regs));
	if(ret < 0)
		vfe_dev_err("sensor_ae_awb_lockoff error!\n"); 
	
	return ret;
};

static int sensor_s_single_af(struct v4l2_subdev *sd)
{
  int ret;
	struct sensor_info *info = to_state(sd);

	vfe_dev_print("sensor_s_single_af\n");
	
	info->focus_status = 0;
	coarse_af_pd = 0;
	sensor_ae_awb_lockon(sd);
	
	ret = sensor_write_array(sd, sensor_af_single_trig_regs , ARRAY_SIZE(sensor_af_single_trig_regs));
	if(ret < 0) {
		vfe_dev_err("sensor_s_single_af error!\n"); 
		sensor_ae_awb_lockoff(sd);
  } else if(ret == 0) {
  	info->focus_status = 1;
  }
	
	
#if 0	

  rdval = 0xffff;
	cnt = 0;
	while(rdval!=0x0002)
	{
		ret = sensor_write(sd, 0x002c , 0x7000);
		ret = sensor_write(sd, 0x002e , 0x2eee);
		if(ret < 0)
		{
			vfe_dev_err("sensor_s_single_af error!\n"); 
	    goto af_out;
	  }
		ret =  sensor_read(sd, 0x0f12 , &rdval);
  	if (ret < 0)
  	{
  		vfe_dev_err("sensor_s_single_af read error !\n");
  		goto af_out;
  	}
  	vfe_dev_dbg("Single AF 1st ,value = 0x%4x\n",rdval);
  	
  	if(rdval!=0x0001 && rdval!=0x0002) {
  		vfe_dev_err("Single AF 1st is failed,value = 0x%4x\n",rdval);
			ret = -EFAULT;
  		goto af_out;
  	} else {
			usleep_range(15000,20000);
			cnt++;
			if(cnt>60) {
				vfe_dev_err("Single AF 1st is timeout,value = 0x%4x\n",rdval);
				ret = -EFAULT;
	  		goto af_out;
			}
		}
	}
	vfe_dev_print("Single AF 1st is complete,value = 0x%4x\n",rdval);
	
	rdval = 0xffff;
  cnt = 0;
	while((rdval&0xff00)!=0x0000)
	{
		ret = sensor_write(sd, 0x002c , 0x7000);
		ret = sensor_write(sd, 0x002e , 0x2207);
		if(ret < 0)
		{
			vfe_dev_err("sensor_s_single_af error!\n"); 
	    goto af_out;
	  }
	  
		ret =  sensor_read(sd, 0x0f12 , &rdval);
  	if (ret < 0)
  	{
  		vfe_dev_err("sensor_s_single_af read error !\n");
  		goto af_out;
  	}
  	usleep_range(5000,10000);
  	
		cnt++;
		if(cnt>300) {
			vfe_dev_err("Single AF 2nd is timeout,value = 0x%4x\n",rdval);
			ret = -EFAULT;
  		goto af_out;
		}
	}
	vfe_dev_print("Single AF 2nd is complete,value = 0x%4x\n",rdval);
	
af_out:	
	sensor_ae_awb_lockoff(sd);
#endif	

	return ret;
}

static int sensor_g_single_af(struct v4l2_subdev *sd)
{
	unsigned short rdval;
	int ret;
	struct sensor_info *info = to_state(sd);
	
	vfe_dev_dbg("sensor_g_single_af\n");
	vfe_dev_dbg("coarse_af_pd = %d\n",coarse_af_pd);
	if(coarse_af_pd != 1) {
	  rdval = 0xffff;
	  sensor_write(sd, 0x002c , 0x7000);
		sensor_write(sd, 0x002e , 0x2eee);
	  ret =  sensor_read(sd, 0x0f12 , &rdval);
		if (ret < 0)
		{
			vfe_dev_err("sensor_g_single_af read error !\n");
			ret = -EAGAIN;
			goto af_out;
		}
	
	  if(rdval == 0x0001 ) {
			vfe_dev_dbg("Single AF 1st is busy,value = 0x%4x\n",rdval);
			msleep(50);
			coarse_af_pd = 0;
			return EBUSY;
		} else if (rdval == 0x0002) {
			coarse_af_pd = 1;
			vfe_dev_print("Single AF 1st is complete,value = 0x%4x\n",rdval);
		} else {
			vfe_dev_print("Single AF 1st is failed,value = 0x%4x\n",rdval);
			info->focus_status = 0;
			coarse_af_pd = 2;
			ret = EFAULT;
			goto af_out;
		}
	}
	
	rdval = 0xffff;
	sensor_write(sd, 0x002c , 0x7000);
	sensor_write(sd, 0x002e , 0x2207);
	ret =  sensor_read(sd, 0x0f12 , &rdval);
	if (ret < 0)
	{
		vfe_dev_err("sensor_g_single_af read error !\n");
		goto af_out;
	}
	

	if((rdval&0xff00)!=0x0000) {
		vfe_dev_dbg("Single AF 2nd is busy,value = 0x%4x\n",rdval);
		return EBUSY;
	}
	
	vfe_dev_print("Single AF 2nd is complete,value = 0x%4x\n",rdval);
	info->focus_status = 0;
	
	ret = 0;
af_out:	
	
	sensor_ae_awb_lockoff(sd);
	
	return ret;
}

static int sensor_g_contin_af(struct v4l2_subdev *sd)
{
  
  
  
  	return V4L2_AUTO_FOCUS_STATUS_IDLE;
}

static int sensor_g_af_status(struct v4l2_subdev *sd)
{
  int ret=0;
  struct sensor_info *info = to_state(sd);
	
	if(info->auto_focus==1)
		ret = sensor_g_contin_af(sd);
	else
		ret = sensor_g_single_af(sd);
	
	return ret;
}


static int sensor_s_init_af(struct v4l2_subdev *sd)
{
	int ret;
  struct sensor_info *info = to_state(sd);
	ret=sensor_download_af_fw(sd);
	if(ret==0)
		info->af_first_flag=0;
	return ret;
}

static int sensor_s_infinity_af(struct v4l2_subdev *sd)
{
  int ret;
  
  vfe_dev_print("sensor_s_infinity_af\n");
  ret = sensor_write_array(sd,sensor_af_infinity_regs,ARRAY_SIZE(sensor_af_infinity_regs));
  if(ret < 0)
    vfe_dev_err("sensor_s_infinity_af error\n");
   
  return ret;
}

static int sensor_s_pause_af(struct v4l2_subdev *sd)
{
	return 0;
}

static int sensor_s_release_af(struct v4l2_subdev *sd)
{
	return 0;
}

static int sensor_s_continueous_af(struct v4l2_subdev *sd, int value)
{
  int ret = 0;
	struct sensor_info *info = to_state(sd);

  vfe_dev_print("sensor_s_continueous_af[0x%x]\n",value);
	
	if(value==1)
  {
    ret = sensor_write_array(sd,sensor_af_continueous_regs,ARRAY_SIZE(sensor_af_continueous_regs));
    if(ret < 0)
      vfe_dev_err("sensor_s_continueous_af error\n");
    info->auto_focus=1;
  }
  else
  {
    LOG_ERR_RET(sensor_s_infinity_af(sd));
		info->auto_focus=0;
  }
  
  return ret;
}


static int sensor_s_af_zone(struct v4l2_subdev *sd,
														struct v4l2_win_coordinate * win_c)
{
	struct sensor_info *info = to_state(sd);
	
  int x1,y1,x2,y2;
  unsigned int xc,yc;
  unsigned int prv_x,prv_y;
  
	int fst_win_start_x,fst_win_start_y;
	int fst_disp_start_x,fst_disp_start_y;
	int fst_win_size_x = 512,fst_win_size_y = 568;
	int fst_disp_size_x,fst_disp_size_y;
	int scnd_win_start_x,scnd_win_start_y;
	int scnd_disp_start_x,scnd_disp_start_y;
	int scnd_win_size_x = 116,scnd_win_size_y = 306;
	int scnd_disp_size_x,scnd_disp_size_y;
	
	if(info->focus_status == 1)
		return 0;
	
  if(info->width == 0 || info->height == 0) {
    vfe_dev_err("current width or height is zero!\n");
    return -EINVAL;
  }
  vfe_dev_print("sensor_s_af_zone\n");
  
  prv_x=(int)info->width;
  prv_y=(int)info->height;
  
  x1=win_c->x1;
  y1=win_c->y1;
  x2=win_c->x2;
  y2=win_c->y2;
  
#ifdef AF_WIN_NEW_COORD
  xc=prv_x*((unsigned int)(2000+x1+x2)/2)/2000;
  yc=(prv_y*((unsigned int)(2000+y1+y2)/2)/2000);
#else
  xc=(x1+x2)/2;
  yc=(y1+y2)/2;
#endif
	vfe_dev_dbg("af zone input xc=%d,yc=%d\n",xc,yc);	
  
	
	fst_disp_size_x = fst_win_size_x * info->width /1024;
	
	if(xc + fst_disp_size_x/2 > info->width) {
		fst_disp_start_x = info->width - fst_disp_size_x;
	} else if(xc - (fst_disp_size_x/2) < 0) {
		fst_disp_start_x = 0;
	} else {
		fst_disp_start_x = xc - (fst_disp_size_x/2);
	}
	
	fst_disp_size_y = fst_win_size_y * info->height /1024;
	if(yc + fst_disp_size_y/2 > info->height) {
		fst_disp_start_y = info->height - fst_disp_size_y;
	} else if(yc - fst_disp_size_y/2 < 0) {
		fst_disp_start_y = 0;
	} else {
		fst_disp_start_y = yc - fst_disp_size_y/2;
	}
	
	fst_win_start_x = fst_disp_start_x * 1024 / info->width;
	fst_win_start_y = fst_disp_start_y * 1024 / info->height;
	
	
	scnd_disp_size_x = scnd_win_size_x * info->width /1024;
	if(xc + scnd_disp_size_x/2 > info->width) {
		scnd_disp_start_x = info->width - scnd_disp_size_x;
	} else if(xc - scnd_disp_size_x/2 < 0) {
		scnd_disp_start_x = 0;
	} else {
		scnd_disp_start_x = xc - scnd_disp_size_x/2;
	}
	
	scnd_disp_size_y = scnd_win_size_y * info->height /1024;
	if(yc + scnd_disp_size_y/2 > info->height) {
		scnd_disp_start_y = info->height - scnd_disp_size_y;
	} else if(yc - scnd_disp_size_y/2 < 0) {
		scnd_disp_start_y = 0;
	} else {
		scnd_disp_start_y = yc - scnd_disp_size_y/2;
	}
	
	scnd_win_start_x = scnd_disp_start_x * 1024 / info->width;
	scnd_win_start_y = scnd_disp_start_y * 1024 / info->height;
	
	sensor_write(sd, 0x0028, 0x7000);
	sensor_write(sd, 0x002a, 0x0294);
	sensor_write(sd, 0x0f12, fst_win_start_x);
	sensor_write(sd, 0x0f12, fst_win_start_y);
	sensor_write(sd, 0x0f12, fst_win_size_x); 
	sensor_write(sd, 0x0f12, fst_win_size_y); 
	sensor_write(sd, 0x0f12, scnd_win_start_x);
	sensor_write(sd, 0x0f12, scnd_win_start_y);
	sensor_write(sd, 0x0f12, scnd_win_size_x);
	sensor_write(sd, 0x0f12, scnd_win_size_y);
	sensor_write(sd, 0x0f12, 0x0001);					
	
	vfe_dev_dbg("af zone 1st window stx=%d,sty=%d,width=%d,height=%d\n",fst_win_start_x,fst_win_start_y,fst_win_size_x,fst_win_size_y);
	vfe_dev_dbg("af zone 2nd window stx=%d,sty=%d,width=%d,height=%d\n",scnd_win_start_x,scnd_win_start_y,scnd_win_size_x,scnd_win_size_y);
	
	usleep_range(30000,31000);
	return 0;
}


#if 0
static int sensor_s_relaunch_af_zone(struct v4l2_subdev *sd)
{
	return 0;
}
#endif


static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
{
	return -EINVAL;
}

static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
{
	return -EINVAL;
}

static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
{
	return -EINVAL;
}

static int sensor_s_autoexp(struct v4l2_subdev *sd,
		enum v4l2_exposure_auto_type value)
{
	return -EINVAL;
}

static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
{
	struct sensor_info *info = to_state(sd);
	
	*value = info->autowb;
	return 0;
}

static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	
	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
	if (ret < 0) {
		vfe_dev_err("sensor_write_array err at sensor_s_autowb!\n");
		return ret;
	}
	
	usleep_range(10000,12000);
	info->autowb = value;
	
	return 0;
}

static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
{
	return -EINVAL;
}

static int sensor_s_hue(struct v4l2_subdev *sd, int value)
{
	return -EINVAL;
}

static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
{
	return -EINVAL;
}

static int sensor_s_gain(struct v4l2_subdev *sd, int value)
{
	return -EINVAL;
}

static int sensor_g_band_filter(struct v4l2_subdev *sd, 
		__s32 *value)
{
	struct sensor_info *info = to_state(sd);
	
	*value = info->band_filter;
	return 0;
}

static int sensor_s_band_filter(struct v4l2_subdev *sd, 
		enum v4l2_power_line_frequency value)
{
	struct sensor_info *info = to_state(sd);

	int ret = 0;
	
	switch(value) {
		case V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
			break;			
		case V4L2_CID_POWER_LINE_FREQUENCY_50HZ:
			ret = sensor_write_array(sd, sensor_flicker_50hz_regs, ARRAY_SIZE(sensor_flicker_50hz_regs));
			if (ret < 0)
				vfe_dev_err("sensor_write_array err at sensor_s_band_filter!\n");
			break;
		case V4L2_CID_POWER_LINE_FREQUENCY_60HZ:
			ret = sensor_write_array(sd, sensor_flicker_60hz_regs, ARRAY_SIZE(sensor_flicker_60hz_regs));
			if (ret < 0)
				vfe_dev_err("sensor_write_array err at sensor_s_band_filter!\n");
		  break;
		case V4L2_CID_POWER_LINE_FREQUENCY_AUTO:
		  break;
	}
	info->band_filter = value;
	return ret;
}

static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  
  *value = info->brightness;
  return 0;
}

static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
{
  struct sensor_info *info = to_state(sd);
  
  if(info->brightness == value)
    return 0;
  
  if(value < -4 || value > 4)
    return -ERANGE;
  
  LOG_ERR_RET(sensor_write_array(sd, sensor_brightness[value+4].regs, sensor_brightness[value+4].size))

  info->brightness = value;
  return 0;
}

static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  
  *value = info->contrast;
  return 0;
}

static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
{
  struct sensor_info *info = to_state(sd);
  
  if(info->contrast == value)
    return 0;
  
  if(value < -4 || value > 4)
    return -ERANGE;
    
  LOG_ERR_RET(sensor_write_array(sd, sensor_contrast[value+4].regs, sensor_contrast[value+4].size))
  
  info->contrast = value;
  return 0;
}

static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  
  *value = info->saturation;
  return 0;
}

static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
{
  struct sensor_info *info = to_state(sd);
  
  if(info->saturation == value)
    return 0;

  if(value < -4 || value > 4)
    return -ERANGE;
      
  LOG_ERR_RET(sensor_write_array(sd, sensor_saturation[value+4].regs, sensor_saturation[value+4].size))

  info->saturation = value;
  return 0;
}

static int sensor_g_exp_bias(struct v4l2_subdev *sd, __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  
  *value = info->exp_bias;
  return 0;
}

static int sensor_s_exp_bias(struct v4l2_subdev *sd, int value)
{
  struct sensor_info *info = to_state(sd);

  if(info->exp_bias == value)
    return 0;

  if(value < -4 || value > 4)
    return -ERANGE;
      
  LOG_ERR_RET(sensor_write_array(sd, sensor_ev[value+4].regs, sensor_ev[value+4].size))

  info->exp_bias = value;
  return 0;
}

static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
{
  struct sensor_info *info = to_state(sd);
  enum v4l2_auto_n_preset_white_balance *wb_type = (enum v4l2_auto_n_preset_white_balance*)value;
  
  *wb_type = info->wb;
  
  return 0;
}

static int sensor_s_wb(struct v4l2_subdev *sd,
    enum v4l2_auto_n_preset_white_balance value)
{
  struct sensor_info *info = to_state(sd);
  
  if(info->capture_mode == V4L2_MODE_IMAGE)
    return 0;
  
  if(info->wb == value)
    return 0;
  
  LOG_ERR_RET(sensor_write_array(sd, sensor_wb[value].regs ,sensor_wb[value].size) )
  
  if (value == V4L2_WHITE_BALANCE_AUTO) 
    info->autowb = 1;
  else
    info->autowb = 0;
  
  info->wb = value;
  return 0;
}

static int sensor_g_colorfx(struct v4l2_subdev *sd,
    __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
  
  *clrfx_type = info->clrfx;
  return 0;
}

static int sensor_s_colorfx(struct v4l2_subdev *sd,
    enum v4l2_colorfx value)
{
  struct sensor_info *info = to_state(sd);

  if(info->clrfx == value)
    return 0;
  
  LOG_ERR_RET(sensor_write_array(sd, sensor_colorfx[value].regs, sensor_colorfx[value].size))

  info->clrfx = value;
  return 0;
}

static int sensor_g_flash_mode(struct v4l2_subdev *sd,
    __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  enum v4l2_flash_led_mode *flash_mode = (enum v4l2_flash_led_mode*)value;
  
  *flash_mode = info->flash_mode;
  return 0;
}

static int sensor_s_flash_mode(struct v4l2_subdev *sd,
    enum v4l2_flash_led_mode value)
{
  struct sensor_info *info = to_state(sd);
  
  info->flash_mode = value;
  return 0;
}


/*
 * Stuff that knows about the sensor.
 */
 
static int sensor_power(struct v4l2_subdev *sd, int on)
{
  
  switch(on)
	{
		case CSI_SUBDEV_STBY_ON:
			vfe_dev_dbg("CSI_SUBDEV_STBY_ON\n");
			cci_lock(sd);
      vfe_gpio_write(sd,RESET,CSI_RST_ON);
			usleep_range(1000,1200);
      vfe_gpio_write(sd,PWDN,CSI_STBY_ON);
			usleep_range(1000,1200);
      vfe_set_mclk(sd,OFF);
			cci_unlock(sd);	
			break;
		case CSI_SUBDEV_STBY_OFF:
			vfe_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
			cci_lock(sd);
			vfe_set_mclk_freq(sd,MCLK);
			vfe_set_mclk(sd,ON);
			usleep_range(1000,1200);
      vfe_gpio_write(sd,PWDN,CSI_STBY_OFF);
			usleep_range(1000,1200);
      vfe_gpio_write(sd,RESET,CSI_RST_OFF);
			usleep_range(1000,1200);
			cci_unlock(sd);
			break;
		case CSI_SUBDEV_PWR_ON:
			vfe_dev_dbg("CSI_SUBDEV_PWR_ON\n");
			cci_lock(sd);
      vfe_gpio_set_status(sd,PWDN,1);//set the gpio to output
      vfe_gpio_set_status(sd,RESET,1);//set the gpio to output
      vfe_gpio_write(sd,PWDN,CSI_STBY_ON);
      vfe_gpio_write(sd,RESET,CSI_RST_ON);
      vfe_gpio_write(sd,POWER_EN,CSI_PWR_ON);
      vfe_set_pmu_channel(sd,IOVDD,ON);
      vfe_set_pmu_channel(sd,AVDD,ON);
      vfe_set_pmu_channel(sd,DVDD,ON);
      vfe_set_pmu_channel(sd,AFVDD,ON);
			usleep_range(10000,12000);
      vfe_set_mclk_freq(sd,MCLK);
      vfe_set_mclk(sd,ON);
      vfe_gpio_write(sd,PWDN,CSI_STBY_OFF);
			usleep_range(10000,12000);
      vfe_gpio_write(sd,RESET,CSI_RST_OFF);
			usleep_range(10000,12000);
			cci_unlock(sd);	
			break;
		case CSI_SUBDEV_PWR_OFF:
			vfe_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
			cci_lock(sd);
      vfe_gpio_write(sd,RESET,CSI_RST_ON);
			udelay(100);
      vfe_set_mclk(sd,OFF);
			udelay(10);
      vfe_gpio_write(sd,PWDN,CSI_STBY_ON);	
      vfe_gpio_write(sd,POWER_EN,CSI_PWR_OFF);
      vfe_set_pmu_channel(sd,IOVDD,OFF);
      vfe_set_pmu_channel(sd,AVDD,OFF);
      vfe_set_pmu_channel(sd,DVDD,OFF);
      vfe_set_pmu_channel(sd,AFVDD,OFF);
			vfe_gpio_set_status(sd,PWDN,0);//set the gpio to input
			vfe_gpio_set_status(sd,RESET,0);//set the gpio to input
			cci_unlock(sd);	
			break;
		default:
			return -EINVAL;
	}		

	return 0;
}
 
static int sensor_reset(struct v4l2_subdev *sd, u32 val)
{
  switch(val)
  {
    case 0:
      vfe_gpio_write(sd,RESET,CSI_RST_OFF);
      usleep_range(10000,12000);
      break;
    case 1:
      vfe_gpio_write(sd,RESET,CSI_RST_ON);
      usleep_range(10000,12000);
      break;
    default:
      return -EINVAL;
  }
    
  return 0;
}

static int sensor_detect(struct v4l2_subdev *sd)
{
	int ret;
	unsigned short rdval=0xffff;
	
	ret = sensor_write(sd, 0x002c, 0x7000);
	ret = sensor_write(sd, 0x002e, 0x01a4);
	if (ret < 0)
	{
		vfe_dev_err("sensor_write err at sensor_detect!\n");
		return ret;
	}

	ret = sensor_read(sd, 0x0f12, &rdval);

	if(rdval != 0x4ec0 )
	{
		vfe_dev_err("id read from sensor is 0x%4x,not 0x4ec0\n",rdval);
		return -ENODEV;
	}
	
	return 0;
}

static int sensor_init(struct v4l2_subdev *sd, u32 val)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	
	vfe_dev_dbg("sensor_init\n");
	
	/*Make sure it is a target sensor*/
	ret = sensor_detect(sd);
	if (ret) {
		vfe_dev_err("chip found is not an target chip.\n");
		return ret;
	}
	
  vfe_get_standby_mode(sd,&info->stby_mode);
  
  if((info->stby_mode == HW_STBY || info->stby_mode == SW_STBY) \
      && info->init_first_flag == 0) {
    vfe_dev_print("stby_mode and init_first_flag = 0\n");
    return 0;
  } 
  
	info->focus_status = 0;
	info->width = 0;
	info->height = 0;
	info->brightness = 0;
	info->contrast = 0;
	info->saturation = 0;
	info->hue = 0;
	info->hflip = 0;
	info->vflip = 0;
	info->gain = 0;
	info->autogain = 1;
	info->exp = 0;
	info->autoexp = 0;
	info->autowb = 1;
	info->wb = V4L2_WHITE_BALANCE_AUTO;
	info->clrfx = V4L2_COLORFX_NONE;
	info->band_filter = V4L2_CID_POWER_LINE_FREQUENCY_50HZ;
	info->tpf.numerator = 1;            
	info->tpf.denominator = 30;    /* 30fps */
	info->width = 0;
	info->height = 0;
	
	ret = sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));	
	if(ret < 0) {
		vfe_dev_err("write sensor_default_regs error\n");
		return ret;
	}
			
	sensor_s_band_filter(sd, V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
	
  if(info->stby_mode == 0)
    info->init_first_flag = 0;
  
  info->preview_first_flag = 1;
	return 0;
}

static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
{
	int ret=0;
	return ret;
}


/*
 * Store information about the video data format. 
 */
static struct sensor_format_struct {
	__u8 *desc;
	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
	struct regval_list *regs;
	int	regs_size;
	int bpp;   /* Bytes per pixel */
} sensor_formats[] = {

	{
		 .desc   = "MIPI YUV422",
    .mbus_code  = V4L2_MBUS_FMT_UYVY8_16X1,
    .regs     = sensor_fmt_mipi_yuv422,
    .regs_size = ARRAY_SIZE(sensor_fmt_mipi_yuv422),
    .bpp    = 2,
	},

	/*{
		.desc		= "YUYV 4:2:2",
		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
		.regs 		= sensor_fmt_yuv422_yuyv,
		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
		.bpp		= 2,
	},
	{
		.desc		= "YVYU 4:2:2",
		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
		.regs 		= sensor_fmt_yuv422_yvyu,
		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
		.bpp		= 2,
	},
	{
		.desc		= "UYVY 4:2:2",
		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
		.regs 		= sensor_fmt_yuv422_uyvy,
		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
		.bpp		= 2,
	},
	{
		.desc		= "VYUY 4:2:2",
		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
		.regs 		= sensor_fmt_yuv422_vyuy,
		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
		.bpp		= 2,
	},*/
};
#define N_FMTS ARRAY_SIZE(sensor_formats)

	

/*
 * Then there is the issue of window sizes.  Try to capture the info here.
 */


static struct sensor_win_size sensor_win_sizes[] = {
	/* qsxga: 2592*1936 */
	{
		.width			= QSXGA_WIDTH,
		.height 		= QSXGA_HEIGHT,
		.regs			  = sensor_qsxga_regs,
    .hoffset    = 0,
    .voffset    = 0,
		.regs_size	= ARRAY_SIZE(sensor_qsxga_regs),
		.set_size		= NULL,
	},
	/* qxga: 2048*1536 */
	{
		.width			= QXGA_WIDTH,
		.height 		= QXGA_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
		.regs			  = sensor_qxga_regs,
		.regs_size	= ARRAY_SIZE(sensor_qxga_regs),
		.set_size		= NULL,
	},
	/* 1080P */
	{
		.width			= HD1080_WIDTH,
		.height			= HD1080_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
		.regs 			= sensor_1080p_regs,
		.regs_size	= ARRAY_SIZE(sensor_1080p_regs),
		.set_size		= NULL,
	},

	/* 720p */
	{
		.width			= HD720_WIDTH,
		.height			= HD720_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
		.regs 			= sensor_720p_regs,
		.regs_size	= ARRAY_SIZE(sensor_720p_regs),
		.set_size		= NULL,
	},
	/* VGA */
	{
		.width			= VGA_WIDTH,
		.height			= VGA_HEIGHT,
    .hoffset    = 0,
    .voffset    = 0,
		.regs				= sensor_vga_regs,
		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
		.set_size		= NULL,
	},
};

#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))




static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
                 enum v4l2_mbus_pixelcode *code)
{
	if (index >= N_FMTS)//linux-3.0
		return -EINVAL;

	*code = sensor_formats[index].mbus_code;
	return 0;
}

static int sensor_enum_size(struct v4l2_subdev *sd,
                            struct v4l2_frmsizeenum *fsize)
{
  if(fsize->index > N_WIN_SIZES-1)
  	return -EINVAL;
  
  fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
  fsize->discrete.width = sensor_win_sizes[fsize->index].width;
  fsize->discrete.height = sensor_win_sizes[fsize->index].height;
  
  return 0;
}


static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
    struct v4l2_mbus_framefmt *fmt,
    struct sensor_format_struct **ret_fmt,
    struct sensor_win_size **ret_wsize)
{
  int index;
  struct sensor_win_size *wsize;

  for (index = 0; index < N_FMTS; index++)
    if (sensor_formats[index].mbus_code == fmt->code)
      break;

  if (index >= N_FMTS) 
    return -EINVAL;
  
  if (ret_fmt != NULL)
    *ret_fmt = sensor_formats + index;
    
  /*
   * Fields: the sensor devices claim to be progressive.
   */
  
  fmt->field = V4L2_FIELD_NONE;
  
  /*
   * Round requested image size down to the nearest
   * we support, but not below the smallest.
   */
  for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
       wsize++)
    if (fmt->width >= wsize->width && fmt->height >= wsize->height)
      break;
    
  if (wsize >= sensor_win_sizes + N_WIN_SIZES)
    wsize--;   /* Take the smallest one */
  if (ret_wsize != NULL)
    *ret_wsize = wsize;
  /*
   * Note the size we'll actually handle.
   */
  fmt->width = wsize->width;
  fmt->height = wsize->height;
  fmt->reserved[0] = wsize->hoffset;
  fmt->reserved[1] = wsize->voffset;

  return 0;
}

static int sensor_try_fmt(struct v4l2_subdev *sd, 
             struct v4l2_mbus_framefmt *fmt)
{
  return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
}

static int sensor_g_mbus_config(struct v4l2_subdev *sd,
           struct v4l2_mbus_config *cfg)
{
  cfg->type = V4L2_MBUS_PARALLEL;
  cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL ;
  
  return 0;
}

/*
 * Set a format.
 */
static int sensor_s_fmt(struct v4l2_subdev *sd, 
             struct v4l2_mbus_framefmt *fmt)//linux-3.0
{
	int ret;
	struct sensor_format_struct *sensor_fmt;
	struct sensor_win_size *wsize;
	struct sensor_info *info = to_state(sd);
	
	vfe_dev_dbg("sensor_s_fmt\n");
	
  
	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
	if (ret)
		return ret;
	
	if(info->fmt == sensor_fmt && info->width == wsize->width && info->height == wsize->height)
	{
		vfe_dev_print("format and size remain the same\n");
		goto update;
	}
		
	if(info->capture_mode == V4L2_MODE_VIDEO ||
	   info->capture_mode == V4L2_MODE_PREVIEW)
	{
	}
	else if(info->capture_mode == V4L2_MODE_IMAGE)
	{
		ret = sensor_set_exposure(sd);
		if (ret < 0)
		{
			vfe_dev_err("sensor_set_exposure err !\n");
			return ret;
		}	
	}
	
	ret = sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
	if (ret < 0)		
		return ret;
	
	ret = 0;
	if (wsize->regs)
		LOG_ERR_RET(sensor_write_array(sd, wsize->regs , wsize->regs_size));
	
	if (wsize->set_size)
		LOG_ERR_RET(wsize->set_size(sd));
	
	if(info->capture_mode == V4L2_MODE_VIDEO || info->capture_mode == V4L2_MODE_PREVIEW)
	{
	}

update:
	info->fmt = sensor_fmt;
	info->width = wsize->width;
	info->height = wsize->height;
	
	vfe_dev_print("s_fmt set width = %d, height = %d\n",wsize->width,wsize->height);
		
	
	return 0;
}


/*
 * Implement G/S_PARM.  There is a "high quality" mode we could try
 * to do someday; for now, we just do the frame rate tweak.
 */
static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
{
	struct v4l2_captureparm *cp = &parms->parm.capture;
	struct sensor_info *info = to_state(sd);

	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		return -EINVAL;
	
	memset(cp, 0, sizeof(struct v4l2_captureparm));
	cp->capability = V4L2_CAP_TIMEPERFRAME;
	cp->capturemode = info->capture_mode;
	
	cp->timeperframe.numerator = info->tpf.numerator;
	cp->timeperframe.denominator = info->tpf.denominator;
	 
	return 0;
}

static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
{
  struct v4l2_captureparm *cp = &parms->parm.capture;
  struct v4l2_fract *tpf = &cp->timeperframe;
  struct sensor_info *info = to_state(sd);
  unsigned char div;
  
  vfe_dev_dbg("sensor_s_parm\n");
  
  if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE){
  	vfe_dev_dbg("parms->type!=V4L2_BUF_TYPE_VIDEO_CAPTURE\n");
    return -EINVAL;
  }
  
  if (info->tpf.numerator == 0){
  	vfe_dev_dbg("info->tpf.numerator == 0\n");
    return -EINVAL;
  }
    
  info->capture_mode = cp->capturemode;
  
  if (info->capture_mode == V4L2_MODE_IMAGE) {
    vfe_dev_dbg("capture mode is not video mode,can not set frame rate!\n");
    return 0;
  }
    
  if (tpf->numerator == 0 || tpf->denominator == 0) {
    tpf->numerator = 1;
    tpf->denominator = SENSOR_FRAME_RATE;/* Reset to full rate */
    vfe_dev_err("sensor frame rate reset to full rate!\n");
  }
  
  div = SENSOR_FRAME_RATE/(tpf->denominator/tpf->numerator);
  if(div > 15 || div == 0)
  {
  	vfe_dev_print("SENSOR_FRAME_RATE=%d\n",SENSOR_FRAME_RATE);
  	vfe_dev_print("tpf->denominator=%d\n",tpf->denominator);
  	vfe_dev_print("tpf->numerator=%d\n",tpf->numerator);
    return -EINVAL;
  }
  
  vfe_dev_dbg("set frame rate %d\n",tpf->denominator/tpf->numerator);
  
  info->tpf.denominator = SENSOR_FRAME_RATE; 
  info->tpf.numerator = div;
  
	if(info->tpf.denominator/info->tpf.numerator < 30)
		info->low_speed = 1;
    
  return 0;
}


static int sensor_queryctrl(struct v4l2_subdev *sd,
    struct v4l2_queryctrl *qc)
{
  /* Fill in min, max, step and default value for these controls. */
  /* see include/linux/videodev2.h for details */
  switch (qc->id) {
  case V4L2_CID_VFLIP:
  case V4L2_CID_HFLIP:
    return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
  case V4L2_CID_EXPOSURE:
  case V4L2_CID_AUTO_EXPOSURE_BIAS:
    return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
  case V4L2_CID_EXPOSURE_AUTO:
    return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
  case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
    return v4l2_ctrl_query_fill(qc, 0, 9, 1, 1);
  case V4L2_CID_AUTO_WHITE_BALANCE:
    return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
  case V4L2_CID_COLORFX:
    return v4l2_ctrl_query_fill(qc, 0, 15, 1, 0);
  case V4L2_CID_FLASH_LED_MODE:
    return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);  
  
  case V4L2_CID_AUTO_FOCUS_INIT:
  case V4L2_CID_AUTO_FOCUS_RELEASE:
  case V4L2_CID_AUTO_FOCUS_START:
  case V4L2_CID_AUTO_FOCUS_STOP:
  case V4L2_CID_AUTO_FOCUS_STATUS:
    return v4l2_ctrl_query_fill(qc, 0, 0, 0, 0);
  case V4L2_CID_FOCUS_AUTO:
    return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
  case V4L2_CID_AUTO_EXPOSURE_WIN_NUM:
    return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
  case V4L2_CID_AUTO_FOCUS_WIN_NUM:
    return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
  }
  return -EINVAL;
}

static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
  switch (ctrl->id) {
  case V4L2_CID_BRIGHTNESS:
    return sensor_g_brightness(sd, &ctrl->value);
  case V4L2_CID_CONTRAST:
    return sensor_g_contrast(sd, &ctrl->value);
  case V4L2_CID_SATURATION:
    return sensor_g_saturation(sd, &ctrl->value);
  case V4L2_CID_HUE:
    return sensor_g_hue(sd, &ctrl->value);  
  case V4L2_CID_VFLIP:
    return sensor_g_vflip(sd, &ctrl->value);
  case V4L2_CID_HFLIP:
    return sensor_g_hflip(sd, &ctrl->value);
  case V4L2_CID_GAIN:
    return sensor_g_gain(sd, &ctrl->value);
  case V4L2_CID_AUTOGAIN:
    return sensor_g_autogain(sd, &ctrl->value);
  case V4L2_CID_EXPOSURE:
  case V4L2_CID_AUTO_EXPOSURE_BIAS:
    return sensor_g_exp_bias(sd, &ctrl->value);
  case V4L2_CID_EXPOSURE_AUTO:
    return sensor_g_autoexp(sd, &ctrl->value);
  case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
    return sensor_g_wb(sd, &ctrl->value);
  case V4L2_CID_AUTO_WHITE_BALANCE:
    return sensor_g_autowb(sd, &ctrl->value);
  case V4L2_CID_COLORFX:
    return sensor_g_colorfx(sd, &ctrl->value);
  case V4L2_CID_FLASH_LED_MODE:
    return sensor_g_flash_mode(sd, &ctrl->value);
  case V4L2_CID_POWER_LINE_FREQUENCY:
    return sensor_g_band_filter(sd, &ctrl->value);
  
  case V4L2_CID_AUTO_FOCUS_STATUS:
  	return sensor_g_af_status(sd);
  case V4L2_CID_AUTO_FOCUS_WIN_NUM:
  	ctrl->value=1;
  	return 0;
  case V4L2_CID_AUTO_EXPOSURE_WIN_NUM:
  	ctrl->value=1;
  	return 0;
  }
  return -EINVAL;
}

static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
  struct v4l2_queryctrl qc;
  int ret;
  
  qc.id = ctrl->id;
  ret = sensor_queryctrl(sd, &qc);
  if (ret < 0) {
    return ret;
  }

	if (qc.type == V4L2_CTRL_TYPE_MENU ||
		qc.type == V4L2_CTRL_TYPE_INTEGER ||
		qc.type == V4L2_CTRL_TYPE_BOOLEAN)
	{
	  if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
	    return -ERANGE;
	  }
	}
	
  switch (ctrl->id) {
    case V4L2_CID_BRIGHTNESS:
      return sensor_s_brightness(sd, ctrl->value);
    case V4L2_CID_CONTRAST:
      return sensor_s_contrast(sd, ctrl->value);
    case V4L2_CID_SATURATION:
      return sensor_s_saturation(sd, ctrl->value);
    case V4L2_CID_HUE:
      return sensor_s_hue(sd, ctrl->value);   
    case V4L2_CID_VFLIP:
      return sensor_s_vflip(sd, ctrl->value);
    case V4L2_CID_HFLIP:
      return sensor_s_hflip(sd, ctrl->value);
    case V4L2_CID_GAIN:
      return sensor_s_gain(sd, ctrl->value);
    case V4L2_CID_AUTOGAIN:
      return sensor_s_autogain(sd, ctrl->value);
    case V4L2_CID_EXPOSURE:
    case V4L2_CID_AUTO_EXPOSURE_BIAS:
      return sensor_s_exp_bias(sd, ctrl->value);
    case V4L2_CID_EXPOSURE_AUTO:
      return sensor_s_autoexp(sd,
          (enum v4l2_exposure_auto_type) ctrl->value);
    case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
  		return sensor_s_wb(sd,
          (enum v4l2_auto_n_preset_white_balance) ctrl->value); 
    case V4L2_CID_AUTO_WHITE_BALANCE:
      return sensor_s_autowb(sd, ctrl->value);
    case V4L2_CID_COLORFX:
      return sensor_s_colorfx(sd,
          (enum v4l2_colorfx) ctrl->value);
    case V4L2_CID_FLASH_LED_MODE:
      return sensor_s_flash_mode(sd,
          (enum v4l2_flash_led_mode) ctrl->value);
    case V4L2_CID_POWER_LINE_FREQUENCY:
      return sensor_s_band_filter(sd,
          (enum v4l2_power_line_frequency) ctrl->value);
    
	  case V4L2_CID_AUTO_FOCUS_INIT:
	  	return sensor_s_init_af(sd);
	  case V4L2_CID_AUTO_FOCUS_RELEASE:
	  	return sensor_s_release_af(sd);
	  case V4L2_CID_AUTO_FOCUS_START:
	  	return sensor_s_single_af(sd);
	  case V4L2_CID_AUTO_FOCUS_STOP:
	  	return sensor_s_pause_af(sd);
	  case V4L2_CID_FOCUS_AUTO:
	  	return sensor_s_continueous_af(sd, ctrl->value);
	  case V4L2_CID_AUTO_FOCUS_WIN_NUM:
	  	return sensor_s_af_zone(sd, (struct v4l2_win_coordinate *)(ctrl->user_pt));
	  case V4L2_CID_AUTO_EXPOSURE_WIN_NUM:
	  	return 0;
  }
  return -EINVAL;
}


static int sensor_g_chip_ident(struct v4l2_subdev *sd,
    struct v4l2_dbg_chip_ident *chip)
{
  struct i2c_client *client = v4l2_get_subdevdata(sd);

  return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
}


/* ----------------------------------------------------------------------- */

static const struct v4l2_subdev_core_ops sensor_core_ops = {
  .g_chip_ident = sensor_g_chip_ident,
  .g_ctrl = sensor_g_ctrl,
  .s_ctrl = sensor_s_ctrl,
  .queryctrl = sensor_queryctrl,
  .reset = sensor_reset,
  .init = sensor_init,
  .s_power = sensor_power,
  .ioctl = sensor_ioctl,
};

static const struct v4l2_subdev_video_ops sensor_video_ops = {
  .enum_mbus_fmt = sensor_enum_fmt,
  .enum_framesizes = sensor_enum_size,
  .try_mbus_fmt = sensor_try_fmt,
  .s_mbus_fmt = sensor_s_fmt,
  .s_parm = sensor_s_parm,
  .g_parm = sensor_g_parm,
  .g_mbus_config = sensor_g_mbus_config,
};

static const struct v4l2_subdev_ops sensor_ops = {
  .core = &sensor_core_ops,
  .video = &sensor_video_ops,
};


/* ----------------------------------------------------------------------- */
static struct cci_driver cci_drv = {
	.name = SENSOR_NAME,
};
static int sensor_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	struct v4l2_subdev *sd;
	struct sensor_info *info;

	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
	if (info == NULL)
		return -ENOMEM;
	sd = &info->sd;
  cci_dev_probe_helper(sd, client, &sensor_ops, &cci_drv);

  info->fmt = &sensor_formats[0];
  info->af_first_flag = 1;
  info->init_first_flag = 1;
  info->auto_focus = 0;
	
	return 0;
}


static int sensor_remove(struct i2c_client *client)
{
	struct v4l2_subdev *sd;

	sd = cci_dev_remove_helper(client, &cci_drv);
	kfree(to_state(sd));
	return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{ SENSOR_NAME, 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, sensor_id);

static struct i2c_driver sensor_driver = {
	.driver = {
		.owner = THIS_MODULE,
	.name = SENSOR_NAME,
	},
	.probe = sensor_probe,
	.remove = sensor_remove,
	.id_table = sensor_id,
};
static __init int init_sensor(void)
{
	return cci_dev_init_helper(&sensor_driver);
}

static __exit void exit_sensor(void)
{
	cci_dev_exit_helper(&sensor_driver);
}

module_init(init_sensor);
module_exit(exit_sensor);


